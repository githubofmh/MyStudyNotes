



[TOC]

# 一 计算机网络

## 1. 计算机网络分层模型

### 1）分层模型

![这里写图片描述](https://img-blog.csdn.net/20170328082752460?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMTc3NDUxNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

### 2）OSI模型各层的基本作用

![preview](D:\资料\面试\images\v2-436927a69a3574532059a78623d3095d_r.jpg)

### OSI模型的详解

![preview](D:\资料\面试\images\v2-5ce0438c1e2c59840286b124fc70dd67_r.jpg)

##### 物理层

![img](D:\资料\面试\images\v2-343093645638ea0839b71db5eba1f7c0_hd.jpg)

##### 数据链路层

![img](D:\资料\面试\images\v2-fb8534d86e40986e43449de6c35ebd14_hd.jpg)

##### 网络层

![preview](D:\资料\面试\images\v2-991572825990575d273f653a78bcc5e7_r.jpg)

##### 传输层

![preview](D:\资料\面试\images\v2-31bff54e0720487afe37e5f3f282d231_r.jpg)

##### 应用层

![preview](D:\资料\面试\images\v2-741e4cd7f95897d6a61bd219e208f1c1_r.jpg)

##### 补充

- pc连网的设置详解

![img](D:\资料\面试\images\v2-b09a3718e0501f053b6ed418b087211b_hd.jpg)

- 数据链路层数据包（以太网数据包）格式，除了应用层没有头部，其他都有

![preview](D:\资料\面试\images\v2-3c8ab7e3f330238821adedea31b9c321_r.jpg)

- 数据包在传送时的封装和解封装如下所示
- ![img](D:\资料\面试\images\v2-5ce2810c5f0ed99ad92d7d3a43cc652c_hd.jpg)



### 路由器/交换机/集线器是哪一层

<table>
	<tr>
	    <th>层</th>
	    <th>设备</th>
	    <th>作用</th>  
	</tr >
    <tr>
	    <td >应用层</td>
	    <td >应用网关</td>
	    <td rowspan="2">网关，通过字面意思解释就是网络的关口。从技术角度来解释，就是连接两个不同网络的接口，比如局域网的共享上网服务器就是局域网和广域网的接口。</td>
	</tr>
     <tr>
	    <td >传输层</td>
	    <td >传输网关</td>
	</tr>
    <tr>
	    <td >网络层</td>
	    <td >路由器</td>
	    <td >路由器的主要工作就是为经过路由器的每个IP数据包寻找一条最佳传输路径，并将该数据有效地传送到目的站点。 路由器的基本功能是，把数据（IP报文）传送到正确的网络。</td>
	</tr>
	<tr >
	    <td rowspan="2">数据链路层</td>
	    <td>交换机</td>
	    <td>交换机，可以理解为高级的网桥，他有网桥的功能，但性能比网桥强。交换机和网桥的细微差别就在于：交换机常常用来连接独立的计算机，而网桥连接的目标是LAN，所以交换机的端口较网桥多。</td>
	</tr>
	<tr>
	    <td>网桥</td>
	    <td>网桥工作在数据链路层，将两个LAN连起来，根据MAC地址来转发帧，可以看作一个“低层的路由器”。</td>
	</tr>
	<tr >
	    <td rowspan="2">物理层</td>
	    <td>集线器</td>
	    <td>集线器，差不多就是个多端口的中继器，把每个输入端口的信号放大再发到别的端口去，集线器可以实现多台计算机之间的互联，因为它有很多的端口，每个口都能连计算机。</td>
	</tr>
	<tr>
	    <td>中继器</td>
	    <td>中继器，就是简单的信号放大器，信号在传输的过程中是要衰减的，中继器的作用就是将信号放大，使信号能传的更远</td>
	</tr>
</table>



## 传输层协议

### TCP协议

#### 特点：

1）. TCP 是有连接的。
2）. TCP保证可靠交付。
3）. TCP 是面向字节流的。
4）. TCP 有拥塞控制。
5）. TCP 一对一。
6）. TCP 的首部开销大，首部有20个字节。

#### TCP数据包格式

![img](D:\资料\面试\images\75)

#### 三次握手四次挥手

| 字段      | 含义                                                         |
| --------- | ------------------------------------------------------------ |
| URG       | 紧急指针是否有效。为1，表示某一位需要被优先处理              |
| ACK       | 确认号是否有效，一般置为1。                                  |
| PSH       | 提示接收端应用程序立即从TCP缓冲区把数据读走                  |
| RST       | 对方要求重新建立连接，复位。                                 |
| SYN       | 请求建立连接，并在其序列号的字段进行序列号的初始值设定。建立连接，设置为1 |
| FIN       | 希望断开连接。                                               |
| 序列号seq | 占4个字节，用来标记数据段的顺序，序列号seq就是这个报文段中的第一个字节的数据编号。 |
| 确认号ack | 占4个字节，期待收到对方下一个报文段的第一个数据字节的序号；  |

##### 三次握手过程理解



###### ![img](D:\资料\面试\images\70)



1. 第一次握手：建立连接时，客户端发送syn包（syn=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。

2. 第二次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包（syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态；

3. 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

##### 四次挥手过程理解

![img](D:\资料\面试\images\71)

1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

##### 常见面试题

**【问题1】为什么连接的时候是三次握手，关闭的时候却是四次握手？**

答：因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。==其中ACK报文是用来应答的，SYN报文是用来同步的==。但是关闭连接时，当Server端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉Client端，"你发的FIN报文我收到了"。只有等到我Server端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送。故需要四步握手。



为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤
如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认





**两次握手为什么不可以**？
采用三次握手是为了防止失效的连接请求报文段突然又传送到主机B，因而产生错误。失效的连接请求报文段是指：主机A发出的连接请求没有收到主机B的确认，于是经过一段时间后，主机A又重新向主机B发送连接请求，且建立成功，顺序完成数据传输。考虑这样一种特殊情况，主机A第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到主机B，主机B以为是主机A又发起的新连接，于是主机B同意连接，并向主机A发回确认，但是此时主机A根本不会理会，主机B就一直在等待主机A发送数据，导致主机B的资源浪费。 
**为什么要四次挥手？**
TCP关闭链接四次握手原因在于tpc链接是全双工通道，需要双向关闭。client向server发送关闭请求，表示client不再发送数据，server响应。此时server端仍然可以向client发送数据，待server端发送数据结束后，就向client发送关闭请求，然后client确认。

**【问题2】为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。在Client发送出最后的ACK回复，但该ACK可能丢失。Server如果没有收到ACK，将不断重复发送FIN片段。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。

**【问题3】为什么不能用两次握手进行连接？**

答：3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
      现在把三次握手改成仅需要两次握手，死锁是可能发生的。作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，S收到了这个分组，并发 送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

**【问题4】如果已经建立了连接，但是客户端突然出现故障了怎么办？**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

#### 握手时产生的序列号干什么用的

​       TCP之所以可靠，是因为它保证了传送数据包的顺序。顺序是用一个序列号来保证的。响应包内也包括一个序列号，表示接收方准备好这个序列号的包。在TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个包的确认信息，便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包。另外，TCP通过数据分段中的序列号来保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整。

#### 讲一下接收窗口

##### 一、滑动窗口协议

1. “窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；

2. “滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，方式就是按顺序“滑动”。
   1. TCP协议的两端分别为发送者A和接收者B，由于是全双工协议，因此A和B应该分别维护着一个独立的发送缓冲区和接收缓冲区，由于对等性（A发B收和B发A收），我们以A发送B接收的情况作为例子；
   2. 发送窗口是发送缓存中的一部分，是可以被TCP协议发送的那部分，其实应用层需要发送的所有数据都被放进了发送者的发送缓冲区；
   3. 发送窗口中相关的有四个概念：已发送并收到确认的数据（不再发送窗口和发送缓冲区之内）、已发送但未收到确认的数据（位于发送窗口之中）、允许发送但尚未发送的数据以及发送窗口外发送缓冲区内暂时不允许发送的数据；
   4. 每次成功发送数据之后，发送窗口就会在发送缓冲区中按顺序移动，将新的数据包含到窗口中准备发送；
   
   TCP建立连接的初始，B会告诉A自己的接收窗口大小，比如为‘20’：
      字节31-50为发送窗口
   
   ![img](D:\资料\面试\images\26275986_1392626885IL2q.png)
   
   A发送11个字节后，发送窗口位置不变，B接收到了乱序的数据分组
   
   ![img](D:\资料\面试\images\26275986_1392627107R2FQ.png)
   
   只有当A成功发送了数据，即发送的数据得到了B的确认之后，才会移动滑动窗口离开已发送的数据；同时B则确认连续的数据分组，对于乱序的分组则先接收下来，避免网络重复传递：
   
   ![img](D:\资料\面试\images\26275986_13926272726XTE.png)

##### 二、流量控制

 流量控制方面主要有两个要点需要掌握。==一是TCP利用滑动窗口实现流量控制的机制；二是如何考虑流量控制中的传输效率==。
1. 流量控制

  ​       所谓流量控制，主要是接收方传递信息给发送方，使其不要发送数据太快，是一种端到端的控制。主要的方式就是返回的ACK中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送：  

  ​        这里面涉及到一种情况，如果B已经告诉A自己的缓冲区已满，于是A停止发送数据；等待一段时间后，B的缓冲区出现了富余，于是给A发送报文告诉A我的rwnd大小为400，但是这个报文不幸丢失了，于是就出现A等待B的通知||B等待A发送数据的死锁状态。为了处理这种问题，TCP引入了持续计时器（Persistence timer），当A收到对方的零窗口通知时，就启用该计时器，时间到则发送一个1字节的探测报文，对方会在此时回应自身的接收窗口大小，如果结果仍未0，则重设持续计时器，继续等待。 

![img](http://blog.chinaunix.net/attachment/201402/17/26275986_1392627535jeG5.png)


2. 传递效率
             一个显而易见的问题是：单个发送字节单个确认，和窗口有一个空余即通知发送方发送一个字节，无疑增加了网络中的许多不必要的报文（请想想为了一个字节数据而添加的40字节头部吧！），所以我们的原则是尽可能一次多发送几个字节，或者窗口空余较多的时候通知发送方一次发送多个字节。对于前者我们广泛使用Nagle算法，即：
   *1. 若发送应用进程要把发送的数据逐个字节地送到TCP的发送缓存，则发送方就把第一个数据字节先发送出去，把后面的字节先缓存起来；
   *2. 当发送方收到第一个字节的确认后（也得到了网络情况和对方的接收窗口大小），再把缓冲区的剩余字节组成合适大小的报文发送出去；
   *3. 当到达的数据已达到发送窗口大小的一半或以达到报文段的最大长度时，就立即发送一个报文段；
   对于后者我们往往的做法是让接收方等待一段时间，或者接收方获得足够的空间容纳一个报文段或者等到接受缓存有一半空闲的时候，再通知发送方发送数据。

##### 三、拥塞控制

​     网络中的链路容量和交换结点中的缓存和处理机都有着工作的极限，当网络的需求超过它们的工作极限时，就出现了拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。常用的方法就是：

###### 1. 慢开始、拥塞控制

一切的基础还是慢开始，这种方法的思路是这样的：
-1. 发送方维持一个叫做“拥塞窗口”的变量，该变量和接收端口共同决定了发送者的发送窗口；
-2. 当主机开始发送数据时，避免一下子将大量字节注入到网络，造成或者增加拥塞，选择发送一个1字节的试探报文；
-3. 当收到第一个字节的数据的确认后，就发送2个字节的报文；
-4. 若再次收到2个字节的确认，则发送4个字节，依次递增2的指数级；
-5. 最后会达到一个提前预设的“慢开始门限”，比如24，即一次发送了24个分组，此时遵循下面的条件判定：
     *1. cwnd < ssthresh， 继续使用慢开始算法；
     *2. cwnd > ssthresh，停止使用慢开始算法，改用拥塞避免算法；
     *3. cwnd = ssthresh，既可以使用慢开始算法，也可以使用拥塞避免算法；
-6. 所谓拥塞避免算法就是：每经过一个往返时间RTT就把发送方的拥塞窗口+1，即让拥塞窗口缓慢地增大，按照线性规律增长；
-7. 当出现网络拥塞，比如丢包时，将慢开始门限设为原先的一半，然后将cwnd设为1，执行慢开始算法（较低的起点，指数级增长）；

![img](D:\资料\面试\images\26275986_1392629245IG6b.png)

上述方法的目的是在拥塞发生时循序减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕。慢开始和拥塞控制算法常常作为一个整体使用，而快重传和快恢复则是为了减少因为拥塞导致的数据包丢失带来的重传时间，从而避免传递无用的数据到网络。

###### 2. 快重传和快恢复

​    如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。
​    快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。

![img](D:\资料\面试\images\2010101122524670.jpg)

接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。
    与快重传配合使用的还有快恢复算法，其过程有以下两个要点：
    <1>. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。
    <2>. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。
    下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。
    区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。

![img](D:\资料\面试\images\2010101123101842.jpg)

 也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。
    在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。
    采用这样的拥塞控制方法使得TCP的性能有明显的改进。
    接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。
    发送方窗口的上限值 = Min [ rwnd, cwnd ]
    当rwnd < cwnd 时，是接收方的接收能力限制发送方窗口的最大值。
    当cwnd < rwnd 时，则是网络的拥塞限制发送方窗口的最大值。



### 确定发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb/s，接收端100Mb/s

带宽(bits每秒) * 往返延迟(秒) = TCP窗口大小(bits) / 8 = TCP窗口大小(字节)

### UDP协议

#### 概述

用户数据报协议（UDP，User Datagram Protocol）为应用程序提供了一种无需建立连接就可以发送封装的 IP 数据报的方法。UDP是一种保留消息边界的简单的面向数据报的协议。UDP不提供差错纠正、队列管理、重复消除、流量控制和拥塞控制，但提供差错检测（包含我们在传输层中碰到的第一个真实的端到端（end-to-end）校验和）。这种协议自身提供最小功能，因此使用它的应用程序要做许多关于数据报如何发送和处理的控制工作。想要保证数据被可靠传递或正确排序，应用程序必须自己实现这些保护功能。一般来说，每个被应用程序请求的UDP输出操作只产生一个UDP数据报，从而发送一个IP数据报。而对于面向数据流的传输层协议（例如TCP），应用程序写入的全部数据与真正在单个IP数据报里传送的或接收方接收的内容可能没有联系。

#### UDP 的主要特点

1）. UDP 是无连接的，即发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。
2）. UDP 使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表。
3）. UDP 是面向报文的。发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文。
4）. UDP 没有拥塞控制，因此网络出现的拥塞不会使源主机的发送速率降低。很多的实时应用（如IP电话、实时视频会议等）要去源主机以恒定的速率发送数据，并且允许在网络发生拥塞时丢失一些数据，但却不允许数据有太多的时延。UDP正好符合这种要求。
5）. UDP 支持一对一、一对多、多对一和多对多的交互通信。
6）. UDP 的首部开销小，只有8个字节，比TCP的20个字节的首部要短。
虽然某些实时应用需要使用没有拥塞控制的UDP,但当很多的源主机同时都向网络发送高速率的实时视频流时,网络就有可能发生拥塞,结果大家都无法正常接收。因此,不使用拥塞控制功能的UDP有可能会引起网络产生严重的拥塞问题。
还有一些使用UDP的实时应用,需要对UDP的不可靠的传输进行适当的改进,以减少数据的丢失。在这种情况下,应用进程本身可以在不影响应用的实时性的前提下,增加些提高可靠性的措施,如采用前向纠错或重传已丢失的报文。

#### UDP 的首部格式

![img](D:\资料\面试\images\73)

UDP有两个字段：数据字段和首部字段。首部字段很简单，只有8个字节，由4个字段组成，每个字段的长度都是两个字节。各字段意义如下：

源端口：源端口号。在需要对方回信时选用。不需要时可用全0。
目的端口：目的端口号。这在终点交付报文时必须要使用到。
长度： UDP用户数据报的长度，其最小值是8（仅有首部），发送一个带0字节数据的UDP数据报是允许的。值得注意的是，UDP长度字段是冗余的；IPV4头部包含了数据报的总长度，同时IPV6头部包含了负载长度。因此，一个UDP/IPV4数据报的长度等于IPV4数据报的总长度减去IPV4头部的长度。一个UDP/IPV6数据报的长度等于包含在IPV6头部中的负载长度（payload length）字段的值减去所有扩展头部（除非使用了超长数据报）的长度。这两种情况下，UDP长度字段应该与从IP层提供的信息计算得到的长度是一致的。
校验和：检测UDP用户数据报在传输中是否有错。有错就丢弃。

![img](D:\资料\面试\images\611089-20190921220803652-303585216.png)

当运输层从 IP 层收到 UDP 数据报时，根据目的端口，通过相应的端口上交给应用进程。

![img](D:\资料\面试\images\611089-20190921220818242-618108627.png)

如果接收方 UDP发现报文中的目的端口号不正确（即不存在对应于该端口号的应用进程），就丢弃该报文，并由网际控制报文协议 ICMP 发送“端口不可达”差错报文给发送方。
请注意，虽然在 UDP 之间的通信要用到其端口号，但由于 UDP 的通信是无连接的，因此不需要使用套接字（TCP 之间的通信必须要在两个套接字之间建立连接）。

#### UDP 校验和

UDP 校验和是一个端到端的传输层校验和，是对包含了IP头部中的源（Source）和目的IP地址（Destination Address）字段的 UDP 伪首部计算得到的。它由初始的发送方计算得到，由最终的目的方校验。它在传输中不会被修改（除非它通过一个NAT）。IPV4 头部中的校验和只覆盖整个头部（即它不覆盖IP分组中的任何数据），它在每个IP跳都要被重新计算（因为IPV4 TTL字段的值在数据报转发时会被路由器减少）。传输协议（如 TCP、UDP）使用校验和来覆盖它们的头部和数据。对于 UDP 来说，校验和是可选的，而其他的则是强制的。当 UDP 在IPV6中使用时，校验和的计算与使用是强制的，因为在IP层没有头部校验和。为了给应用程序提供无差错数据，像UDP这样的传输层协议，在投递数据到接收方应用程序之前，必须计算校验和或者使用其他差错监测机制。

###### 伪首部

在UDP伪首部中，包含32位源IP地址，32位目的IP地址，8位填充0，8位协议，16位UDP长度。伪首部并非TCP&UDP数据报中实际的有效成分。伪首部是一个虚拟的数据结构，其中的信息是从数据报所在IP分组头的分组头中提取的，既不向下传送也不向上递交，而仅仅是为计算校验和。
伪头部的目的是让UDP层验证数据是否已经到达正确的目的地（即，该IP没有接受地址错误的数据报，也没有给UDP一个本该其他传输协议的数据报），计算UDP校验和时覆盖的字段，包含了伪头部以及UDP头部和负载。

###### UDP 校验和计算方法

UDP计算校验和的方法和计算IP数据报首部校验和的方法相似。但不同的是：IP数据报的校验和只检验IP数据报的首部，但UDP的校验和是将首部和数据部分一起都检验。
在发送方，首先是将全零放入检验和字段。再将伪首部以及UDP用户数据报看是由许多16位的字串接起来。若UDP用户数据报的数据部分不是偶数个字节，则要填入一个全零字节(最后一个奇数字节应是16位数的高字节而低字节填0，此字节不发送)。 然后按二进制反码计算出这些16位字的和。 将此和的二进制反码写入校验和字段后，发送此UDP用户数据报。
在接收方，把收到的UDP用户数据报连同伪首部(以及可能的填充全零字节)一起，按二进制反码求这些16位字的和。当无差错时其结果应全为1。否则就表明有差错出现，接收方就丢弃此UDP用户数据报(也可以上交给应用层，但附上出现了差错的警告)。如果校验和字段值为0x0000表示发送方没有计算校验和。

![img](D:\资料\面试\images\611089-20190921220858650-698194870.png)

如上图所示，伪首部的第3字段是全零；第4字段是IP首部中的协议字段的值。对于UDP，此协议字段值为17；第5字段是UDP用户数据报的长度。因此，这样的检验和，既检查了UDP用户数据报的源端口和目的端口以及UDP用户数据报的数据部分，又检查了IP数据报的源IP地址和目的地址。注意，UDP数据报的长度在校验和的计算中出现了两次。
计算原理是二进制反码求和运算，具体来说就是：

```java
0 + 0 = 0
1 + 0 = 0 + 1 = 1
1 + 1 = 10
```

如果最高位有进位，就把进位的1取下来与最低位再做一次二进制加法
示例：

![img](D:\资料\面试\images\611089-20190921220925929-1271333030.png)

图3-2-1 中二进制反码求和的参考代码:

```c++
#include<cstring>
using namespace std;
const int MAX_NUM = 65536; // 2^16 = 1 0000 0000 0000 0000
int a[15] = {153*256+19,8*256+104,171*256+3,14*256+11,17,15,1087,13,15,21573,21332,18766,18176};
// 256 = 2^8 = 1 0000 0000
int main()
{
    int sum = 0;
    for(int i=0;i<13;i++){
        sum += a[i];
        if(sum > MAX_NUM){
            sum = sum % MAX_NUM + 1;
        }
    }
    printf("%d\n",sum);
    
    return 0;
}
```

|                                                              |
| ------------------------------------------------------------ |
| 注意：UDP协议（传输层）直接操作IP（网络层）的比特，会导致所谓的“违反分层”（layering violation）规则。但这只对协议实现产生微小的影响，因为一般来说，当数据传递到（或来自于）UDP时，IP层的信息已经是现成的了。相比之下，更应该关注NAT，特别是当UDP数据报被分片时。 |

尽管UDP数据报校验和在原始UDP规范中是可选的，目前它们还是被要求在主机中默认使用[RFC1122]。在20世纪80年代,一些计算机供应商默认关闭了UDP校验和功能以加速其Sun网络文件系统(NFS)的实现，该网络文件系统使用了UDP。因为有第2层的CRC保护(这要比互联网校验和更强壮)，在许多情况下这可能不会产生问题，然而默认关闭校验和功能被认为是一种不好的方法(也是违反RFC规范的)。早期的互联网经验表明,当数据报通过路由器时，总会存在有软件和硬件漏洞的路由器在转发数据报时会修改其中的比特。如果端到端的UDP校验和被关闭的话，这些UDP数据报中的错误就无法检测到。同时注意到一些更老的数据链路协议(比如，串行线IP或SLIP)没有任何形式的数据链路校验和，因此存在IP分组被修改而检测不到的可能性，除非引入另一种校验和。
考虑到伪头部这样的结构，可以很清楚地看到，当一个UDP/IPv4数据报穿过一个NAT时，不仅IP层头部的校验和要被修改，而且UDP伪头部的校验和也必须被正确地修改，因为IP层的地址和/或UDP层的端日号可能会改变。因此NAT通常因同时修玫分组中协议的多层而违反分层规则。当然，考虑到伪头部本身就是违反分层规则的， NAT没有选择。UDP流量被NAT处理时的一些特定规则由[RFC4784]给出。

#### 两种纠错方式

丢包重传（ARQ）和前向纠错（FEC）

### TCP和UDP的本质区别

TCP向上层提供面向连接的可靠服务 ，UDP向上层提供无连接不可靠服务。

### 什么时候选择TCP/UDP

TCP ：对数据准确性要求比较高，例如金融等大多数领域

UDP：对数据准确性要求不特别高，对时延要求较高的场景，例如游戏、视频、直播和娱乐场景。

## 传输层协议

### HTTP协议

#### HTTP可以使用UDP吗

HTTP/3 使用了UDP

Google 就自己架起炉灶搞了一个基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上

#### HTTP状态码

| 状态码 | 类别                             | 含义                       |
| ------ | -------------------------------- | -------------------------- |
| 1XX    | Informational（信息性状态码）    | 接收的请求正在处理         |
| 2XX    | Success（成功状态码）            | 请求正常处理完毕           |
| 3XX    | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| 4XX    | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| 5XX    | Server Error（服务器错误状态码） | 服务器处理请求出错         |

**1XX 信息**

- 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。

**2XX 成功**

- 200 OK
- 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。

**3XX 重定向**

- 301 Moved Permanently ：永久性重定向
- 302 Found ：临时性重定向
- 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。
- 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器
- 都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。
- 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。

**4XX 客户端错误**

- 400 Bad Request ：请求报文中存在语法错误。
- 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- 403 Forbidden ：请求被拒绝。
- 404 Not Found

**5XX 服务器错误**

- 500 Internal Server Error ：服务器正在执行请求时发生错误。
- 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

### Https协议

#### HTTPS的连接过程

![img](D:\资料\面试\images\watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMzk3NjE1,size_16,color_FFFFFF,t_70)

一个HTTPS请求实际上包含了两次HTTP传输，可以细分为8步。
1.客户端向服务器发起HTTPS请求，连接到服务器的443端口
2.服务器端有一个密钥对，即公钥和私钥，是用来进行非对称加密使用的，服务器端保存着私钥，不能将其泄露，公钥可以发送给任何人。
3.服务器将自己的公钥发送给客户端。
4.客户端收到服务器端的公钥之后，会对公钥进行检查，验证其合法性，如果发现发现公钥有问题，那么HTTPS传输就无法继续。严格的说，这里应该是验证服务器发送的数字证书的合法性，关于客户端如何验证数字证书的合法性，下文会进行说明。如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，我们将该密钥称之为client key，即客户端密钥，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了，**至此，HTTPS中的第一次HTTP请求结束。**
5.客户端会发起HTTPS中的第二个HTTP请求，将加密之后的客户端密钥发送给服务器。
6.服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，解密之后的明文就是客户端密钥，然后用客户端密钥对数据进行对称加密，这样数据就变成了密文。
7.然后服务器将加密后的密文发送给客户端。
8.客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这**样HTTPS中的第二个HTTP请求结束，整个HTTPS传输完成。**



#### HTTPS 的作用

HTTPS简单而言，即使建立在SSL/TLS协议之上的HTTP。不使用SSL/TLS的HTTP通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

| （1） 窃听风险（eavesdropping）：第三方可以获知通信内容。    |
| ------------------------------------------------------------ |
| （2） 篡改风险（tampering）：第三方可以修改通信内容。        |
| （3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。 |

SSL/TLS协议是为了解决这三大风险而设计的，希望达到：

| （1） 所有信息都是加密传播，第三方无法窃听。         |
| ---------------------------------------------------- |
| （2） 具有校验机制，一旦被篡改，通信双方会立刻发现。 |
| （3） 配备身份证书，防止身份被冒充。                 |



#### HTTPS 的基本运行过程：

1）利用对称加密算法来加密网页内容，那么如何保证对称加密算法的秘钥的安全呢？
2）使用非对称加密算法来获得对称加密算法的秘钥，从而保证了对称加密算法的秘钥的安全，也就保证了对称加密算法的安全。
这里这样安排使用的原理是，利用了对称加密算法和非对称加密算法优点，而避免了它们的缺点。利用了对称加密算法速度快，而非对称加密算法安全的优点；同时巧妙的避免了对称加密算法的不安全性，以及需要同步密钥的缺点，也避免了非对称加密算法的速度慢的缺点。实在是巧妙了。
这里有两个问题：
（1）如何保证非对称加密算法公钥不被篡改？
解决方法：将公钥放在数字证书中。只要证书是可信的，公钥就是可信的。
（2）公钥加密计算量太大，如何减少耗用的时间？
解决方法：每一次对话（session），客户端和服务器端都生成一个"对话密钥"（session key），用它来加密信息。由于"对话密钥"是对称加密算法，所以运算速度非常快，而服务器公钥只用于加密"对话密钥"本身，这样就减少了加密运算的消耗时间。（也就是网页内容的加密使用的是对称加密算法）
因此，SSL/TLS协议的基本过程是这样的：

| （1） 客户端向服务器端索要并验证非对称加密算法的公钥。   |
| -------------------------------------------------------- |
| （2） 双方协商生成对称加密算法的"对话密钥"。             |
| （3） 双方采用对称加密算法和它的"对话密钥"进行加密通信。 |

上面过程的前两步，又称为"握手阶段"（handshake）。
握手阶段的详细过程
"握手阶段"涉及四次通信，我们一个个来看。需要注意的是，"握手阶段"的所有通信都是明文的。
客户端发出请求（ClientHello）
首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。
在这一步，客户端主要向服务器提供以下信息。

| （1） 浏览器支持的SSL/TLS协议版本，比如TLS 1.0版。           |
| ------------------------------------------------------------ |
| （2） 一个浏览器客户端生成的随机数，稍后用于生成对称加密算法的"对话密钥"。 |
| （3） 浏览器支持的各种加密方法，对称的，非对称的，HASH算法。比如RSA非对称加密算法，DES对称加密算法，SHA-1 hash算法。 |
| （4） 浏览器支持的压缩方法。                                 |

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应该向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。
对于虚拟主机的用户来说，这当然很不方便。2006年，TLS协议加入了一个Server Name Indication扩展，允许客户端向服务器提供它所请求的域名。
服务器回应（SeverHello）
服务器收到客户端请求后，向客户端发出回应，这叫做SeverHello。服务器的回应包含以下内容。

| （1） 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。 |
| ------------------------------------------------------------ |
| （2） 一个服务器生成的随机数，稍后用于生成对称加密算法的"对话密钥"。 |
| （3） 确认使用的各种加密方法，比如确认算法使用：RSA非对称加密算法，DES对称加密算法，SHA-1 hash算法 |
| （4） 服务器证书。                                           |

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供"客户端证书"。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。
3） 客户端回应
客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。
如果证书没有问题，客户端就会从证书中取出服务器的非对称加密算法的公钥。然后，向服务器发送下面三项信息。

| （1） 一个随机数。该随机数用服务器发来的公钥进行的使用非对称加密算法加密，防止被窃听。 |
| ------------------------------------------------------------ |
| （2） 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送(比如确认使用：RSA非对称，DES对称，SHA-1 hash算法)。 |
| （3） 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验。 |

上面第一项的随机数，是整个握手阶段出现的第三个随机数，又称"pre-master key"。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的对称加密算法，各自生成本次会话所用的同一把"会话密钥"。也就是说浏览器和服务器各自使用同一个对称加密算法，对三个相同的随机数进行加密，获得了，用来加密网页内容的 对称加密算法的秘钥。(注意：这里浏览器的三个随机数都是明文的，但是服务端获得的"pre-master key"是密文的，所以服务器需要使用非对称加密算法的私钥，来先解密获得"pre-master key"的明文，在来生成对称加密算法的秘钥。这样的目的是为了防止："pre-master key"被窃听，因为发送明文会被窃听，但是发生的是非对称加密算法的加密过后的密文，因为窃听者不知道私钥，所以即使窃听了，也无法解密出其对应的明文。从而保证了最后生成的：用于加密网页内容的对称加密算法的秘钥的安全性！！！)
至于为什么一定要用三个随机数，来生成"会话密钥"，dog250解释得很好：

| "不管是客户端还是服务器，都需要随机数，这样生成的密钥才不会每次都一样。由于SSL协议中证书是静态的，因此十分有必要引入一种随机因素来保证协商出来的密钥的随机性。 |
| ------------------------------------------------------------ |
| 对于RSA密钥交换算法来说，pre-master-key本身就是一个随机数，再加上hello消息中的随机，三个随机数通过一个密钥导出器最终导出一个对称密钥。 |
| pre master的存在在于SSL协议不信任每个主机都能产生完全随机的随机数，如果随机数不随机，那么pre master secret就有可能被猜出来，那么仅适用pre master secret作为密钥就不合适了，因此必须引入新的随机因素，那么客户端和服务器加上pre master secret三个随机数一同生成的密钥就不容易被猜出了，一个伪随机可能完全不随机，可是是三个伪随机就十分接近随机了，每增加一个自由度，随机性增加的 可不是一。" |

这里：其实如果 pre-master-key 和 浏览器生成的随机数都可能被猜出来，那么最后生成的对称加密算法的秘钥就是不安全的。因为三个随机数都可能被窃听到了。
此外，如果前一步，服务器要求客户端证书，客户端会在这一步发送证书及相关信息。
服务器的最后回应
服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的对称加密算法的"会话密钥"。然后，向客户端最后发送下面信息。

| （1）编码改变通知，表示随后的信息都将用双方商定的对称加密算法和密钥进行加密。 |
| ------------------------------------------------------------ |
| （2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供客户端校验。 |


至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用"会话密钥"加密内容。

#### 加密解密基础知识

1）对称加密算法：就是加密和解密使用同一个密钥的加密算法。因为加密方和解密方使用的密钥相同，所以称为称为对称加密，也称为单钥加密方法。
优点是：加密和解密运算速度快，所以对称加密算法通常在消息发送方需要加密大量数据时使用；

缺点是：安全性差，如果一方的密钥遭泄露，那么整个通信就会被破解。另外加密之前双方需要同步密钥;

常用对称加密算法有：DES、3DES、TDEA、Blowfish、RC2、RC4、RC5、IDEA、SKIPJACK、AES等;

2）非对称加密算法：而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥(public key，简称公钥)和私有密钥(private key，简称私钥)。
公钥和私钥是一对：公钥用来加密，私钥解密，而且公钥是公开的，私钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。

有点是：安全性更好，私钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。

缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。

常用的非对称加密算法有：RSA、Elgamal、Rabin、D-H、ECC等；

3）HASH算法：也称为消息摘要算法。将任意长度的二进制值映射为较短的固定长度的二进制值，该二进制值称为哈希值。
常用于检验数据的完整性，检验数据没有被篡改过。常见的又 MD5(MD系列)，SHA-1(SHA系列)

HTTPS 使用到了上面全部三种加密算法。

#### HTTPS怎么确认收到的包就是服务器发来的

对称密钥解密

#### 浏览器中输入网址到获得页面的全过程

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

<img src="D:\资料\面试\images\68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d31312f75726ce8be93e585a5e588b0e5b195e7a4bae587bae69da5e79a84e8bf87e7a88b2e6a7067" alt="img" style="zoom: 50%;" />

#### 输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS



1.问题

拿淘宝来说事。

在浏览器中通常人们输入淘宝的网址有taobao.com www.taobao.com http://www.taobao.com

而最终浏览器中的显示的网址是https://www.taobao.com,这是怎么实现的呢？

2.taobao.com -> www.taobao.com

taobao.com 和www.taobao.com是不同的域名，淘宝会把相似的域名都买下来，都定向到同一个域名下。

当输入taobao.com 返回的是302重定向，使浏览器访问www.taobao.com

而百度的实现方式的通过返回 刷新元信息 http://www.baidu.com/“>

使浏览器刷新到www.baidu.com，实现原理大抵相似。

3.http://www.taobao.com -> https://www.taobao.com

http默认端口是80，https默认端口是443。

很多网站都提供https服务，为了避免用户输入http导致访问80端口出现访问不通的情况，同时也是为了与http版本的网站兼容，服务器监听80端口，对所有的80端口的访问都定向到https的url，实现方式都多种，最简单的就是使用302重定向，将其重定向到https://www.taobao.com

这实现了http->https,但是不能每次都重定向，http协议实现了一个叫做HSTS机制。返回的302报文中有这样一条

```html
Strict-Transport-Security: max-age=31536000\r\n
```

其含义是强制浏览器在max-age到期之前，把所有的http://www.taobao.com自动转换成https://www.taobao.com

是浏览器实现的url转换，不用每次访问两次服务器，一步到位。这样避免了302跳转80->443的中间人劫持的问题。所以之后每次访问就不会出现302了，只有第一次会出现。


TOMCAT 版本

1、在conf目录下的server.xml文件中找到以下配置，修改redirectPort参数值为"443"，默认是“8443”.

```xml
<Connector port="80" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="443" />
```

2、在conf目录下的web.xml文件内容<web-app>……</web-app>中增加以下配置。

```xml
<web-app>
.........
<security-constraint>
    <web-resource-collection >        
   <web-resource-name >SSL</web-resource-name>     
   <url-pattern>/*</url-pattern>
       </web-resource-collection>    
       <user-data-constraint>
<transport-guarantee>CONFIDENTIAL</transport-guarantee>
       </user-data-constraint>
</security-constraint>
</web-app
```



------




# 数据库

## 事务

### 特性

⑴ 原子性（Atomicity）
　　原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，这和前面两篇博客介绍事务的功能是一样的概念，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。
⑵ 一致性（Consistency）
　　一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。
　　拿转账来说，假设用户A和用户B两者的钱加起来一共是5000，那么不管A和B之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。
⑶ 隔离性（Isolation）
　　隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
　　即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。
　　关于事务的隔离性数据库提供了多种隔离级别，稍后会介绍到。
⑷ 持久性（Durability）
　　持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。
　　例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成，否则就会造成我们看到提示事务处理完毕，但是数据库因为故障而没有执行事务的重大错误。

### 读写锁等锁机制介绍

1. 读锁：也称为共享锁（S锁），用于不更改或不更新数据的操作（只读操作），如 SELECT 语句。

   如果事务T对数据A加上共享锁后，则其他事务只能对数据A再加共享锁，不能加排他锁。获准共享锁的事务只能读数据，不能修改数据。

2. 写锁：也称为排他锁（X锁），用于数据修改操作，例如 INSERT、UPDATE 或 DELETE。确保不会同时对同一资源进行多重更新。

   如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

3. 乐观锁(Optimistic Lock)：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。

4. 悲观锁(Optimistic Lock)：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。

5. 行锁：每次操作锁住一行数据（即一行记录）。

   缺点：开销大，加锁慢；会出现死锁。                 优点：锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

6. 表锁：每次操作锁住整张表。

   优点：开销小，加锁快；不会出现死锁。             缺点：锁定粒度大，发生锁冲突的概率最高，并发度最低。

### 什么是死锁和如何解决死锁

如果一组进程中每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。
举例来说：有两个进程A和B,A持有资源a等待b资源，B持有资源b等待a资源，两个进程都在等待另一个资源的同时不释放资源，就形成死锁。

#### 形成死锁的四个必要条件：

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

#### 处理死锁的思路如下：

- 预防死锁：破坏四个必要条件中的一个或多个来预防死锁
- 避免死锁：在资源动态分配的过程中，用某种方式防止系统进入不安全的状态。
- 检测死锁：运行时产生死锁，及时发现思索，将程序解脱出来。
- 解除死锁：发生死锁后，撤销进程，回收资源，分配给正在阻塞状态的进程。

#### 预防死锁的办法：

- 破坏请求和保持条件：1.一次性的申请所有资源。之后不在申请资源，如果不满足资源条件则得不到资源分配。2.只获得初期资源运行，之后将运行完的资源释放，请求新的资源。
- 破坏不可抢占条件：当一个进程获得某种不可抢占资源，提出新的资源申请，若不能满足，则释放所有资源，以后需要，再次重新申请。
- 破坏循环等待条件：对资源进行排号，按照序号递增的顺序请求资源。若进程获得序号高的资源想要获取序号低的资源，就需要先释放序号高的资源。

#### 死锁的解除办法：

1、抢占资源。从一个或多个进程中抢占足够数量的资源，分配给死锁进程，以解除死锁状态。
2、终止（撤销）进程：将一个或多个思索进程终止（撤销），直至打破循环环路，使系统从死锁状态解脱。

### 四种问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）**: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）**: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。
- **不可重复读（Unrepeatableread）**: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）**: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读区别：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

#### 四种隔离

- **READ-UNCOMMITTED(读取未提交)**： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。

- **READ-COMMITTED(读取已提交)**： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。

- **REPEATABLE-READ(可重复读)**： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。

- **SERIALIZABLE(可串行化)**： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。

   mysql默认可重复读。



## MVCC

### 什么是MVCC?

英文全称为Multi-Version Concurrency Control,翻译为中文即 多版本并发控制。在小编看来，他无非就是乐观锁的一种实现方式。在Java编程中，如果把乐观锁看成一个接口，MVCC便是这个接口的一个实现类而已。

![Mysql中MVCC的使用及原理详解](D:\资料\面试\images\1536289030904c0df31db36)

### 特点

1.MVCC其实广泛应用于数据库技术，像Oracle,PostgreSQL等也引入了该技术，即适用范围广
2.MVCC并没有简单的使用数据库的行锁，而是使用了行级锁，row_level_lock,而非InnoDB中的innodb_row_lock.

### 基本原理

MVCC的实现，通过保存数据在某个时间点的快照来实现的。这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

### 基本特征

每行数据都存在一个版本，每次数据更新时都更新该版本。
修改时Copy出当前版本随意修改，各个事务之间无干扰。
保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）

### InnoDB存储引擎MVCC的实现策略

在每一行数据中额外保存两个隐藏的列：当前行创建时的版本号和删除时的版本号（可能为空，其实还有一列称为回滚指针，用于事务回滚，不在本文范畴）。这里的版本号并不是实际的时间值，而是系统版本号。每开始新的事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询每行记录的版本号进行比较。
每个事务又有自己的版本号，这样事务内执行CRUD操作时，就通过版本号的比较来达到数据版本控制的目的。

### MVCC下InnoDB的增删查改是怎么work的

1.插入数据（insert）:记录的版本号即当前事务的版本号
执行一条数据语句：insert into testmvcc values(1,"test");
假设事务id为1，那么插入后的数据行如下：

![Mysql中MVCC的使用及原理详解](D:\资料\面试\images\1536286392011332dc79980)

2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。
比如，针对上面那行记录，事务Id为2 要把name字段更新
update table set name= 'new_value' where id=1;

![Mysql中MVCC的使用及原理详解](D:\资料\面试\images\15362864790262a85896e55)

3、删除操作的时候，就把事务版本号作为删除版本号。比如
delete from table where id=1;

![Mysql中MVCC的使用及原理详解](D:\资料\面试\images\15362865324150dfbc7bf66)

4、查询操作：
从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来：
1) 删除版本号未指定或者大于当前事务版本号，即查询事务开启后确保读取的行未被删除。(即上述事务id为2的事务查询时，依然能读取到事务id为3所删除的数据行)
2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在当前事务中（等于的情况）或者在当前事务启动之前的其他事物进行的insert。
（即事务id为2的事务只能读取到create version<=2的已提交的事务的数据集）

> 补充：
> 1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.
> 2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.
> 原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。
> 3.串行化由于是会对所涉及到的表加锁，并非行锁，自然也就不存在行的版本控制问题。
> 4.通过以上总结，可知，MVCC主要作用于事务性的，有行锁控制的数据库模型。

### 关于Mysql中MVCC的总结

客观上，我们认为他就是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。
但由于Mysql的写操作会加排他锁（前文有讲），如果锁定了还算不算是MVCC？
了解乐观锁的小伙伴们，都知道其主要依靠版本控制，即消除锁定，二者相互矛盾，so从某种意义上来说，Mysql的MVCC并非真正的MVCC，他只是借用MVCC的名号实现了读的非阻塞而已。

## 索引

### 什么是索引

索引（Index）是帮助数据库高效获取数据的数据结构。索引是在基于数据库表创建的，它包含一个表中某些列的值以及记录对应的地址，并且把这些值存储在一个数据结构中。最常见的就是使用哈希表、B+树作为索引。
一般的应用系统，读写比例在10:1左右，而且插入操作和一般的更新操作很少出现性能问题，在生产环境中，我们遇到最多的，也是最容易出问题的，还是一些复杂的查询操作，因此对查询语句的优化显然是重中之重。说起加速查询，就不得不提到索引了。

### 聚簇索引与非聚簇索引

- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因

澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值

#### 何时使用聚簇索引与非聚簇索引

![img](D:\资料\面试\images\2)

### 聚簇索引具有唯一性

由于聚簇索引是将数据跟索引结构放到一块，因此一个表仅有一个聚簇索引

==一个误区：把主键自动设为聚簇索引==

聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。如果你已经设置了主键为聚簇索引，必须先删除主键，然后添加我们想要的聚簇索引，最后恢复设置主键即可。
此时其他索引只能被定义为非聚簇索引。这个是最大的误区。有的主键还是无意义的自动增量字段，那样的话Clustered index对效率的帮助，完全被浪费了。
刚才说到了，聚簇索引性能最好而且具有唯一性，所以非常珍贵，必须慎重设置。一般要根据这个表最常用的SQL查询方式来进行选择，某个字段作为聚簇索引，或组合聚簇索引，这个要看实际情况。
记住我们的最终目的就是在相同结果集情况下，尽可能减少逻辑IO。
结合图再仔细点看

![img](D:\资料\面试\images\164)

![img](D:\资料\面试\images\22)

- InnoDB使用的是聚簇索引，将主键组织到一棵B+树中，而行数据就储存在叶子节点上，若使用"where id = 14"这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。
- 若对Name列进行条件搜索，则需要两个步骤：第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键。第二步使用主键在主索引B+树种再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。（重点在于通过其他键需要建立辅助索引）

MyISM使用的是非聚簇索引，非聚簇索引的两棵B+树看上去没什么不同，节点的结构完全一致只是存储的内容不同而已，主键索引B+树的节点存储了主键，辅助键索引B+树存储了辅助键。表数据存储在独立的地方，这两颗B+树的叶子节点都使用一个地址指向真正的表数据，对于表数据来说，这两个键没有任何差别。由于索引树是独立的，通过辅助键检索无需访问主键的索引树。

#### 聚簇索引的优势

看上去聚簇索引的效率明显要低于非聚簇索引，因为每次使用辅助索引检索都要经过两次B+树查找，这不是多此一举吗？聚簇索引的优势在哪？

1. 由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。
2. 辅助索引使用主键作为"指针"而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个"指针"。也就是说行的位置（实现中通过16K的Page来定位）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。
3. 聚簇索引适合用在排序的场合，非聚簇索引不适合
4. 取出一定范围数据的时候，使用用聚簇索引
5. 二级索引需要两次索引查找，而不是一次才能取到数据，因为存储引擎第一次需要通过二级索引找到索引的叶子节点，从而找到数据的主键，然后在聚簇索引中用主键再次查找索引，再找到数据
6. 可以把相关数据保存在一起。例如实现电子邮箱时，可以根据用户 ID 来聚集数据，这样只需要从磁盘读取少数的数据页就能获取某个用户的全部邮件。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。

#### 聚簇索引的劣势

维护索引很昂贵，特别是插入新行或者主键被更新导至要分页(page split)的时候。建议在大量插入新行后，选在负载较低的时间段，通过OPTIMIZE TABLE优化表，因为必须被移动的行数据可能造成碎片。使用独享表空间可以弱化碎片
表因为使用UUId（随机ID）作为主键，使数据存储稀疏，这就会出现聚簇索引有可能有比全表扫面更慢，

![img](D:\资料\面试\images\728)

所以建议使用int的auto_increment作为主键

![img](D:\资料\面试\images\730)

主键的值是顺序的，所以 InnoDB 把每一条记录都存储在上一条记录的后面。当达到页的最大填充因子时（InnoDB 默认的最大填充因子是页大小的 15/16，留出部分空间用于以后修改），下一条记录就会写入新的页中。一旦数据按照这种顺序的方式加载，主键页就会近似于被顺序的记录填满（二级索引页可能是不一样的）

3. 如果主键比较大的话，那辅助索引将会变的更大，因为辅助索引的叶子存储的是主键值；过长的主键值，会导致非叶子节点占用占用更多的物理空间 

#### 为什么主键通常建议使用自增id

==聚簇索引的数据的物理存放顺序与索引顺序是一致的==，即：只要索引是相邻的，那么对应的数据一定也是相邻地存放在磁盘上的。如果主键不是自增id，那么可以想 象，它会干些什么，不断地调整数据的物理地址、分页，当然也有其他一些措施来减少这些操作，但却无法彻底避免。但，如果是自增的，那就简单了，它只需要一 页一页地写，索引结构相对紧凑，磁盘碎片少，效率也高。



**自增ID可以保证每次插入时B+索引是从右边扩展的，可以避免B+树和频繁合并和分裂（对比使用UUID）。如果使用字符串主键和随机主键，会使得数据随机插入，效率比较差。**

因为MyISAM的主索引并非聚簇索引，那么他的数据的物理地址必然是凌乱的，拿到这些物理地址，按照合适的算法进行I/O读取，于是开始不停的寻道不停的旋转。聚簇索引则只需一次I/O。（强烈的对比）
不过，如果涉及到大数据量的排序、全表扫描、count之类的操作的话，还是MyISAM占优势些，因为索引所占空间小，这些操作是需要在内存中完成的。
mysql中聚簇索引的设定
聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键来作为聚簇索引。InnoDB 只聚集在同一个页面中的记录。包含相邻健值的页面可能相距甚远。

### 为什么要使用索引

我们知道，数据库查询是数据库最主要的功能之一。而查询速度当然是越快越好。而当数据量越来越大的时候，查询花费的时间会随之增长。而索引，可以加速数据的查询。因为索引是有序排列的。
举个例子来说，假设我们有一个数据库表Employee，这个表分别有三个字段：name，age，address。假设表中有1000条记录。
假如没有使用索引，当我们查询名为“Jesus”的雇员的时候，即调用：
select name,age,address from Employee where name = 'Jesus';
此时数据库不得不在Employee表中对这1000条记录一条一条的进行判断name字段是否为“Jesus”。这也就是所谓的全表扫描。
而当我们在Employee表上的name字段上创建索引时，当我们查询名为“Jesus”的雇员时，会通过索引查找去查询名为“Jesus”的雇员，因为该索引已经按照字母顺序排列，因此要查找名为“Jesus”的记录时会快很多，因为名字首字母为“J”的雇员都是排列在一起的。通过该索引，能获取到表中对应的记录。

### 举例说明使用索引的好处

假设索引（索引是一种数据结构）是链表结构。每个节点存储的是关键字字段（这个例子中对应的是name属性）以及该关键字字段在数据库表的对应的记录的地址。而这些节点是根据name属性排序的（即根据字母顺序排序）。因此，当我们执行上面说的查找名为“Jesus”的sql语句时，数据库会通过该索引来查询，因为该链表是有序排列的，在我们找到第一个name属性为“Jesus”的节点后，继续往后找，当遇到name属性不为“Jesus”的节点时，就无需再往后查找了，因为节点是根据name属性有序排列的啊。假设第一个name=“Jesus”的节点是第499个节点，最后一个name=“Jesus”的节点是第500个节点，那么只需要遍历501个节点就可以了。当发现第501个节点的name字段不为“Jesus”，后面的499个节点也就无需遍历了。通过索引，我们就找到了name为“Jesus”的节点，而通过该节点的另一个属性（关键字字段在数据库表的对应的记录的地址），我们就能获取到Employee表中满足条件name=“Jesus”的记录了。
通过使用索引，查询判断的次数就从1000次缩小到了501次了。起到了加速了查询效率。但实际上数据库中索引的结构，并不是链表结构。

### 数据库中使用什么数据结构作为索引

数据库中实际使用的索引并不会是链表结构，因为效率太低了。 
我们知道链表的查询效率是O(n)。就像上面的例子，遍历了501次才找到第一条符合条件的记录，这是很低效的。而我们知道，数组+二分查找的效率是O(lgn)，但是数组的插入元素以及删除元素的效率很低，因此使用数组做为索引结构并不合适。
另外，在选择数据库索引的结构的时候，要考虑到另一个问题。索引是存在于磁盘中，当索引非常大的时候，达到几个G的时候，无法一次加载到内存中。
考虑到上面两个因素，数据库中索引使用的是树形结构。

### 各种树的名字

有这么几种树：

- B-Tree
- B+-Tree
- B\*-Tree

首先要明白三种树名中的“-”起到的是分隔的作用，并不是“减”的意思。 
因此正确的翻译应该是B树，B+树，B\*树。而不是B-树，B+树，B\*树。因此，当你听到别人说“B减树”的时候，要明白它指的是B-Tree。即B树和B-树是同一种树。
为什么要强调上面这一点呢，因为有的博文中写的是：B树是二叉树，B-树是多路搜索树。
然而B树和B-树都是指B-Tree。引用维基百科上的话：
"B-tree 
Not to be confused with Binary tree."

也就是说，B-Tree并不是Binary tree。**B-Tree的中文名是平衡多路搜索树**。 
（B树的相关介绍在下面）



### 平衡二叉树

树形结构是计算机系统里最重要的数据结构。
我们知道，二叉树的查找的时间复杂度是O(log2N)，其查找效率与深度有关，而普通的二叉树可能由于内部节点排列问题退化成链表，这样查找效率就会很低。因此平衡二叉树是更好的选择，因为它保持平衡，即通过旋转调整结构保持最小的深度。其查找的时间复杂度也是O(log2N)。
但实际上，数据库中索引的结构也并非AVL树或更优秀的红黑树，尽管它的查询的时间复杂度很低。

![img](D:\资料\面试\images\1.JPG)

1.所有非叶子结点至多拥有两个儿子（Left和Right）；
2.所有结点存储一个关键字；
3.非叶子结点的左指针指向小于其关键字的子树，右指针指向大于其关键字的子树；

​        二叉树的搜索，从根结点开始，如果查询的关键字与结点的关键字相等，那么就命中；否则，如果查询关键字比结点关键字小，就进入左儿子；如果比结点关键字大，就进入右儿子；如果左儿子或右儿子的指针为空，则报告找不到相应的关键字；
​       如果二叉树的所有非叶子结点的左右子树的结点数目均保持差不多（平衡），那么B树的搜索性能逼近二分查找；但它比连续内存空间的二分查找的优点是，改变二叉树结构（插入与删除结点）不需要移动大段的内存数据，甚至通常是常数开销；

![img](D:\资料\面试\images\2.JPG)

但二叉树在经过多次插入与删除后，有可能导致不同的结构：

![img](D:\资料\面试\images\31.JPG)

​       右边也是一个B树，但它的搜索性能已经是线性的了；同样的关键字集合有可能导致不同的树结构索引；所以，使用B树还要考虑尽可能让B树保持左图的结构，和避免右图的结构，也就是所谓的“平衡”问题；      
​       实际使用的B树都是在原B树的基础上加上平衡算法，即“平衡二叉树”；如何保持B树结点分布均匀的平衡算法是平衡二叉树的关键；平衡算法是一种在B树中插入和删除结点的策略；

#### 为什么平衡二叉树也不适合作为索引

之前说了平衡树的查找时间复杂度是O(log2N)，已经很不错了，但还是不适合作为索引结构。那么肯定是有一种更适合作为索引的数据结构。那么这个更适合作为索引的数据结构，难道是查找的时间复杂度更低吗？并不是。这种作为索引的数据结构的查找的时间复杂度也近似O(log2N)。
**那为什么平衡二叉树不适合作为索引呢？**
索引是存在于索引文件中，是存在于磁盘中的。因为索引通常是很大的，因此无法一次将全部索引加载到内存当中，因此每次只能从磁盘中读取一个磁盘页的数据到内存中。而这个磁盘的读取的速度较内存中的读取速度而言是差了好几个级别。
注意，我们说的平衡二叉树结构，指的是逻辑结构上的平衡二叉树，其物理实现是数组。然后由于在逻辑结构上相近的节点在物理结构上可能会差很远。因此，每次读取的磁盘页的数据中有许多是用不上的。因此，查找过程中要进行许多次的磁盘读取操作。
而适合作为索引的结构应该是尽可能少的执行磁盘IO操作，因为执行磁盘IO操作非常的耗时。因此，平衡二叉树并不适合作为索引结构。

### B-Tree适合作为索引

平衡二叉树不适合作为索引。那么什么才适合作为索引——B树。
平衡二叉树没能充分利用磁盘预读功能，而B树是为了充分利用磁盘预读功能来而创建的一种数据结构，也就是说B树就是为了作为索引才被发明出来的的。
来看看关于“局部性原理与磁盘预读”的知识： 

| 局部性原理与磁盘预读：                                       |
| ------------------------------------------------------------ |
| 由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理： <br/>当一个数据被用到时，其附近的数据也通常会马上被使用。 <br/>程序运行期间所需要的数据通常比较集中。 <br/>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。 |

搞清楚上面的意思。磁盘预读是具体实现，其理论依据是局部性原理。

为什么说红黑树没能充分利用磁盘预读功能，引用一篇博文的一段话： 

" **红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。**"

也就是说，使用红黑树（平衡二叉树）结构的话，每次磁盘预读中的很多数据是用不上的数据。因此，它没能利用好磁盘预读的提供的数据。然后又由于深度大（较B树而言），所以进行的磁盘IO操作更多。
B树的每个节点可以存储多个关键字，它将节点大小设置为磁盘页的大小，充分利用了磁盘预读的功能。每次读取磁盘页时就会读取一整个节点。也正因每个节点存储着非常多个关键字，树的深度就会非常的小。进而要执行的磁盘读取操作次数就会非常少，更多的是在内存中对读取进来的数据进行查找。
B树的查询，主要发生在内存中，而平衡二叉树的查询，则是发生在磁盘读取中。因此，虽然B树查询查询的次数不比平衡二叉树的次数少，但是相比起磁盘IO速度，内存中比较的耗时就可以忽略不计了。因此，B树更适合作为索引。

![img](D:\资料\面试\images\4.JPG)

### B+树——比B树更适合作为索引的结构

比B树更适合作为索引的结构是B+树。MySQL中也是使用B+树作为索引。它是B树的变种，因此是基于B树来改进的。为什么B+树会比B树更加优秀呢？
B树：有序数组+平衡多叉树； 
B+树：有序数组链表+平衡多叉树；
B+树的关键字全部存放在叶子节点中，非叶子节点用来做索引，而叶子节点中有一个指针指向一下个叶子节点。做这个优化的目的是为了提高区间访问的性能。而正是这个特性决定了B+树更适合用来存储外部数据。
引用一段话： 

走进搜索引擎的作者梁斌老师针对B树、B+树给出了他的意见（为了真实性，特引用其原话，未作任何改动）： “B+树还有一个最大的好处，**方便扫库，B树必须用中序遍历的方法按序扫库**，而B+树直接从叶子结点挨个扫一遍就完了，**B+树支持range-query非常方便，而B树不支持。这是数据库选用B+树的最主要原因**。 
比如要查 5-10之间的，B+树一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。**B树的好处，就是成功查询特别有利，因为树的高度总体要比B+树矮。不成功的情况下，B树也比B+树稍稍占一点点便宜。** 
**B树比如你的例子中查，17的话，一把就得到结果了，** 
有很多**基于频率的搜索是选用B树**，越频繁query的结点越往根上走，前提是需要对query做统计，而且要对key做一些变化。 
另外B树也好B+树也好，根或者上面几层因为被反复query，所以这几块基本都在内存中，不会出现读磁盘IO，一般已启动的时候，就会主动换入内存。”

举个例子来对比。 
B树： 

比如说，我们要查找关键字范围在3到7的关键字，在找到第一个符合条件的数字3后，访问完第一个关键字所在的块后，得遍历这个B树，获取下一个块，直到遇到一个不符合条件的关键字。遍历的过程是比较复杂的。
B+树(叶节点保存数据，其他的节点 全部存放索引)： 

相比之下，B+树的基于范围的查询简洁很多。由于叶子节点有指向下一个叶子节点的指针，因此从块1到块2的访问，通过块1指向块2的指针即可。从块2到块3也是通过一个指针即可。
引用一篇博文中网友评论的一段话： 
数据库索引采用**B+树的主要原因是B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。正是为了解决这个问题，B+树应运而生**。
**B+树只要遍历叶子节点就可以实现整棵树的遍历**。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作（或者说效率太低）。
正如上面所说，在数据库中基于范围的查询是非常频繁的，因此MySQL最终选择的索引结构是B+树而不是B树。

![img](D:\资料\面试\images\5.JPG)

#### B+树的性质

##### 1.索引字段要尽量的小

通过上面的分析，我们知道IO次数取决于b+数的高度h，假设当前数据表的数据为N，每个磁盘块的数据项的数量是m，则有h=㏒(m+1)N，当数据量N一定的情况下，m越大，h越小；而m = 磁盘块的大小 / 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如int占4字节，要比bigint8字节少一半。这也是为什么b+树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于1时将会退化成线性表。

##### 2.索引的最左匹配特性（即从左往右匹配）

当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即索引的最左匹配特

### B\*树

是B+树的变体，在B+树的非根和非叶子结点再增加指向兄弟的指针；

![img](D:\资料\面试\images\6.JPG)

 B\*树定义了非叶子结点关键字个数至少为(2/3)*M，即块的最低使用率为2/3（代替B+树的1/2）；
       B+树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；
       B\*树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针；
       所以，B\*树分配新结点的概率比B+树要低，空间使用率更高；

### 索引使用注意事项

1，不要滥用索引
①，索引提高查询速度，却会降低更新表的速度，因为更新表时，mysql不仅要更新数据，保存数据，还要更新索引，保存索引
②，索引会占用磁盘空间 
2，索引不会包含含有NULL值的列
复合索引只要有一列含有NULL值,那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL。 
3，MySQL查询只是用一个索引
如果where字句中使用了索引的话，那么order by中的列是不会使用索引的 
4，like
like '%aaa%'不会使用索引而like "aaa%"可以使用索引

### 选择索引的数据类型

Mysql支持很多数据类型，选择合适的数据类型存储数据对性能有很大的影响。
(1)越小的数据类型通常更好：越小的数据类型通常在磁盘、内存和cpu缓存中都需要更少的空间，处理起来更快。
(2)简单的数据类型更好：整形数据比起字符，处理开销更小，因为字符串的比较更复杂。在MySQL中，应用内置的日期和时间数据类型，而不是字符串来存储时间；以及用整形数据存储IP地址。
(3)尽量避免NULL：应该制定列为NOT NULL，除非你想存储NULL。在MySQL中，含有空值的列很难进行查询优化，因为他们使得索引、索引的统计信息以及比较运算更加复杂。

### MySQL常见索引

1，INDEX（普通索引）：ALTER TABLE 'table_name' ADD INDEX index_name('col')
最基本的索引，没有任何限制 
2，UNIQUE（唯一索引）：ALTER TABLE 'table_name' ADD UNIQUE('col')
与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。 
3，PRIMARY KEY（主键索引）：ALTER TABLE 'table_name' ADD PRIMARY KEY('col')
是一种特殊的唯一索引，不允许有空值。 
4，FULLTEXT（全文索引）：ALTER TABLE 'table_name' ADD FULLTEXT('col')
仅可用于MyISAM和InoDB，针对较大的数据，生成全文索引很耗时耗空间
组合索引：ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')
为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，一次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1,col1col2,col1col2col3三个索引

# 操作系统

### 为什么要分用户态和内核态

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – 用户态和内核态。

### 用户态如何切换到内核态

##### 1、发生系统调用时

这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。而系统调用的机制，其核心仍是使用了操作系统为用户特别开发的一个中断机制来实现的，即软中断。

##### 2、产生异常时

当CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行的进程切换到处理此异常的内核相关的程序中，也就是转到了内核态，如缺页异常。

##### 3、外设产生中断时

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。
可以看到上述三种由用户态切换到内核态的情况中，只有系统调用是进程主动请求发生切换的，中断和异常都是被动的。

### 进程间通信的方式

##### 进程间通讯的方式：

1.无名管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

2.高级管道(popen)：将另一个程序当做一个新的进程在当前程序进程中启动，则它算是当前程序的子进程，这种方式我们成为高级管道方式。

3.有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。

4.消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

5.信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

6.信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。

7.共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。==**共享内存是最快的 IPC 方式**==，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

8.套接字( socket ) ： 套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。

##### 几种方式的比较：

管道：速度慢，容量有限

消息队列：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题。

信号量：不能传递复杂消息，只能用来同步

共享内存区：能够很容易控制容量，速度快，但要保持同步，比如一个进程在写的时候，另一个进程要注意读写的问题，相当于线程中的线程安全，当然，共享内存区同样可以用作线程间通讯，不过没这个必要，线程间本来就已经共享了一块内存的。

### 信号量怎么实现对共享资源的访问

信号量和P/V操作是实现进程互斥与同步的非常有效的方法。

用信号量和P/V操作实现进程互斥与同步的代码结构为：

P(S)

临界区

V(S)



------



# JAVA

## Java SE

### 数据类型

java的数据类型可以分为两类

- 基本数据类型 8 个:
  - 整型：byte,short,int,long
    - byte:1 字节    -128~127
    - short:2个字节  -32768~32767
    - int :4个字节
    - long:8个字节；
  - 浮点：float,double
    - float:4个字节      float f=45.5f;
    - double:8个字节；
  - 布尔：boolean
    - boolean:布尔类型，只能有两个值；true,false;
  - 字符：char
    - char:一个单字符；用单引号引用；任何文字均可（中文，日文)

- 引用数据类型


位：bit

字节：1字节=8位二进制；

### 常量池

![img](D:\资料\面试\images\1353903-20180906112833927-1544152281.png)

==常量池则存在于方法区==

#### String池

**面试题：String str4 = new String(“abc”) 创建多少个对象？**

1. 在常量池中查找是否有“abc”对象
   - 有则返回对应的引用实例
   - 没有则创建对应的实例对象
2. 在堆中 new 一个 String("abc") 对象
3. 将对象地址赋值给str4,创建一个引用

所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用
**根据字面量，往往会提出这样的变式题：**

```java
String str1 = new String("A"+"B") ; 会创建多少个对象? 
String str2 = new String("ABC") + "ABC" ; 会创建多少个对象?
```

str1：
字符串常量池："A","B","AB" : 3个
堆：new String("AB") ：1个
引用： str1 ：1个
总共 ： 5个
str2 ：
字符串常量池："ABC" : 1个
堆：new String("ABC") ：1个
引用： str2 ：1个
总共 ： 3个

通过new操作符创建的字符串对象不指向字符串池中的任何对象，但是可以通过使用字符串的intern()方法来指向其中的某一个。==java.lang.String.intern()==返回一个保留池字符串，就是一个在全局字符串池中有了一个入口。如果以前没有在全局字符串池中，那么它就会被添加到里面

```java
// Create three strings in three different ways.
String s1 = "Hello";
String s2 = new StringBuffer("He").append("llo").toString();
String s3 = s2.intern();

// Determine which strings are equivalent using the ==
// operator
System.out.println("s1 == s2? " + (s1 == s2)); // false
System.out.println("s1 == s3? " + (s1 == s3)); // true
```



#### Interger池

==**基础类型的变量和常量，变量和引用存储在栈中，常量存储在常量池中**==

```java
int a1 = 1;
int a2 = 1;
int a3 = 1;

public static int INT1 =1 ;
public static int INT2 =1 ;
public static int INT3 =1 ;
```

![img](D:\资料\面试\images\1353903-20180906112946541-61268293.png)

new 方法会直接在堆里面创建一个对象

```java
Integer i1 = x 等价于 Integer i1 = Integer.valueOf(x);
```

- 如果 -128 < x <127，直接返回常量池中的变量
- 如果不在这个范围内 rerun new Integer(x)



### 重载与重写

##### 重写方法必须满足下列条件

- 子类的方法的名称及参数必须和所覆盖的方法相同
- 子类的方法返回类型必须和所覆盖的方法相同，或是覆盖方法的子类
- 子类方法不能缩小所覆盖方法的访问权限
- 子类方法不能抛出比所覆盖方法更多的异常

##### 重载方法必须满足下列条件

- 方法名必须相同
- 方法的参数签名必须相同
- 方法的返回类型和方法的修饰符可以不相同



### 访问修饰符

|           | 类内部 | 同包 | 不同包子类 | 不同包非子类 |
| --------- | ------ | ---- | ---------- | ------------ |
| private   | yes    | no   | no         | no           |
| 默认      | yes    | yes  | no         | no           |
| protected | yes    | yes  | yes        | no           |
| public    | yes    | yes  | yes        | yes          |



### 抽象类与接口的区别？

- 抽象类中可以包含普通属性，普通方法，抽象方法和构造方法，而接口中只能包含抽象方法和public static final的属性；
- 抽象类只能被单继承；而一个类可以同时实现多个接口；一个接口可以同时继承多个接口；
- 抽象类通常表示一个概念，而接口表示一种能力；



### 类加载机制

#### 类加载过程

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的生命周期包括了：加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(Unloading)七个阶段，其中验证、准备、解析三个部分统称链接


![img](D:\资料\面试\images\20150905224439218)

加载(装载)、验证、准备、初始化和卸载这五个阶段顺序是固定的，类的加载过程必须按照这种顺序开始，而解析阶段不一定；它在某些情况下可以在初始化之后再开始，这是为了运行时动态绑定特性（JIT例如接口只在调用的时候才知道具体实现的是哪个子类）。值得注意的是：这些阶段通常都是互相交叉的混合式进行的，通常会在一个阶段执行的过程中调用或激活另外一个阶段。

##### 1.加载：（重点）

加载阶段是“类加载机制”中的一个阶段，这个阶段通常也被称作“装载”，主要完成：
1.通过“类全名”来获取定义此类的二进制字节流
2.将字节流所代表的静态存储结构转换为方法区的运行时数据结构
3.在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区这些数据的访问入口

相对于类加载过程的其他阶段，加载阶段(准备地说，是加载阶段中获取类的二进制字节流的动作)是开发期可控性最强的阶段，因为加载阶段可以使用系统提供的类加载器(ClassLoader)来完成，也可以由用户自定义的类加载器完成，开发人员可以通过定义自己的类加载器去控制字节流的获取方式。
加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，方法区中的数据存储格式有虚拟机实现自行定义，虚拟机并未规定此区域的具体数据结构。然后在java堆中实例化一个java.lang.Class类的对象，这个对象作为程序访问方法区中的这些类型数据的外部接口。

##### 2.验证：（了解）

验证是链接阶段的第一步，这一步主要的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全。
验证阶段主要包括四个检验过程：文件格式验证、元数据验证、字节码验证和符号引用验证。

###### 1.文件格式验证 

 验证class文件格式规范，例如： class文件是否已魔术0xCAFEBABE开头 ， 主、次版本号是否在当前虚拟机处理范围之内等

###### 2.元数据验证

这个阶段是对字节码描述的信息进行语义分析，以保证起描述的信息符合java语言规范要求。验证点可能包括：这个类是否有父类(除了java.lang.Object之外，所有的类都应当有父类)、这个类是否继承了不允许被继承的类(被final修饰的)、如果这个类的父类是抽象类，是否实现了起父类或接口中要求实现的所有方法。

###### 3.字节码验证

 进行数据流和控制流分析，这个阶段对类的方法体进行校验分析，这个阶段的任务是保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如：保证访法体中的类型转换有效，例如可以把一个子类对象赋值给父类数据类型，这是安全的，但不能把一个父类对象赋值给子类数据类型、保证跳转命令不会跳转到方法体以外的字节码命令上。

###### 4.符号引用验证

符号引用中通过字符串描述的全限定名是否能找到对应的类、符号引用类中的类，字段和方法的访问性(private、protected、public、default)是否可被当前类访问。

##### 3.准备：（了解）

准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。这个阶段中有两个容易产生混淆的知识点，首先是这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中。其次是这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为:
public static int value  = 12;
那么变量value在准备阶段过后的初始值为0而不是12，因为这时候尚未开始执行任何java方法，而把value赋值为123的putstatic指令是程序被编译后，存放于类构造器<clinit>()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。
上面所说的“通常情况”下初始值是零值，那相对于一些特殊的情况，如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量value就会被初始化为ConstantValue属性所指定的值，建设上面类变量value定义为：
public static final int value = 123;
编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value设置为123。

##### 4.解析：（了解）

解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。
符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。
直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。
虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast、getfield、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。
解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。分别对应编译后常量池内的CONSTANT_Class_Info、CONSTANT_Fieldref_Info、CONSTANT_Methodef_Info、CONSTANT_InterfaceMethoder_Info四种常量类型。
1.类、接口的解析
2.字段解析
3.类方法解析
4.接口方法解析

##### 5.初始化：（了解）

类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，或者可以从另外一个角度来表达：初始化阶段是执行类构造器<clinit>()方法的过程。在以下四种情况下初始化过程会被触发执行：
1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。
2.使用java.lang.reflect包的方法对类进行反射调用的时候
3.当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化
4.jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类
在上面准备阶段 public static int value  = 12;  在准备阶段完成后 value的值为0，而在初始化阶调用了类构造器<clinit>()方法，这个阶段完成后value的值为12。
*类构造器<clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块(static块)中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句快可以赋值，但是不能访问。
*类构造器<clinit>()方法与类的构造函数(实例构造函数<init>()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中的第一个执行的<clinit>()方法的类肯定是java.lang.Object。
*由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。
*<clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成<clinit>()方法。
*接口中不能使用静态语句块，但接口与类不太能够的是，执行接口的<clinit>()方法不需要先执行父接口的<clinit>()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<clinit>()方法。
*虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。如果一个类的<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞。

#### 类加载器

JVM设计者把类加载阶段中的“通过'类全名'来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。

##### 1.类与类加载器

对于任何一个类，都需要由加载它的类加载器和这个类来确立其在JVM中的唯一性。也就是说，两个类来源于同一个Class文件，并且被同一个类加载器加载，这两个类才相等。

##### 2.双亲委派模型

从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。

从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：1)启动类加载器（Bootstrap ClassLoader）：负责加载JAVA_HOME\lib目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。2)扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载JAVA_HOME\lib\，该加载器可以被开发者直接使用。3)应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
我们的应用程序都是由这三类加载器互相配合进行加载的，我们也可以加入自己定义的类加载器。这些类加载器之间的关系如下图所示：

![img](D:\资料\面试\images\20150825150524034)

双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。

使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。

```java
protected synchronized Class loadClass(String name, boolean resolve) throws ClassNotFoundException {        
    // 首先检查该name指定的class是否有被加载       
    Class c = findLoadedClass(name);        
    if (c == null) {            
        try {                
            if (parent != null) {                    
                // 如果parent不为null，则调用parent的loadClass进行加载                    
                c = parent.loadClass(name, false);                
            } else {                    
                // parent为null，则调用BootstrapClassLoader进行加载                    
                c = findBootstrapClass0(name);                
            }            
        } 
        catch (ClassNotFoundException e) {                
            // 如果仍然无法加载成功，则调用自身的findClass进行加载                
            c = findClass(name);            
        }        
    }        
    if (resolve) {            
        resolveClass(c);        
    }        
    return c;    
}
```

通过上面代码可以看出，双亲委派模型是通过loadClass()方法来实现的，根据代码以及代码中的注释可以很清楚地了解整个过程其实非常简单：先检查是否已经被加载过，如果没有则调用父加载器的loadClass()方法，如果父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载器加载失败，则先抛出ClassNotFoundException，然后再调用自己的findClass()方法进行加载。

##### 3.自定义类加载器

若要实现自定义类加载器，只需要继承java.lang.ClassLoader 类，并且重写其findClass()方法即可。java.lang.ClassLoader 类的基本职责就是根据一个指定的类的名称，找到或者生成其对应的字节代码，然后从这些字节代码中定义出一个 Java 类，即 java.lang.Class 类的一个实例。除此之外，ClassLoader 还负责加载 Java 应用所需的资源，如图像文件和配置文件等，ClassLoader 中与加载类相关的方法如下：

| 方法                         | 说明                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| getParent()                  | 返回该类加载器的父类加载器。                                 |
| loadClass(String name)       | 加载名称为 二进制名称为name 的类，返回的结果是 java.lang.Class 类的实例。 |
| findClass(String name)       | 查找名称为 name 的类，返回的结果是 java.lang.Class 类的实例。 |
| findLoadedClass(String name) | 查找名称为 name 的已经被加载过的类，返回的结果是 java.lang.Class 类的实例。 |
| resolveClass(Class<?> c)     | 链接指定的 Java 类。                                         |

注意：在JDK1.2之前，类加载尚未引入双亲委派模式，因此实现自定义类加载器时常常重写loadClass方法，提供双亲委派逻辑，从JDK1.2之后，双亲委派模式已经被引入到类加载体系中，自定义类加载器时不需要在自己写双亲委派的逻辑，因此不鼓励重写loadClass方法，而推荐重写findClass方法。
在Java中，任意一个类都需要由加载它的类加载器和这个类本身一同确定其在java虚拟机中的唯一性，即比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提之下才有意义，否则，即使这两个类来源于同一个Class类文件，只要加载它的类加载器不相同，那么这两个类必定不相等(这里的相等包括代表类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法和instanceof关键字的结果)。例子代码如下：

```java
/**
 * 一、ClassLoader加载类的顺序
 *  1.调用 findLoadedClass(String) 来检查是否已经加载类。
 *  2.在父类加载器上调用 loadClass 方法。如果父类加载器为 null，则使用虚拟机的内置类加载器。
 *  3.调用 findClass(String) 方法查找类。
 * 二、实现自己的类加载器
 *  1.获取类的class文件的字节数组
 *  2.将字节数组转换为Class类的实例
 * @author lei 2011-9-1
 */
public class ClassLoaderTest {
    public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
        //新建一个类加载器
        MyClassLoader cl = new MyClassLoader("myClassLoader");
        //加载类，得到Class对象
        Class<?> clazz = cl.loadClass("classloader.Animal");
        //得到类的实例
        Animal animal=(Animal) clazz.newInstance();
        animal.say();
    }
}
class Animal{
    public void say(){
        System.out.println("hello world!");
    }
}
class MyClassLoader extends ClassLoader {
    //类加载器的名称
    private String name;
    //类存放的路径
    private String path = "E:\\workspace\\Algorithm\\src";
    MyClassLoader(String name) {
        this.name = name;
    }
    MyClassLoader(ClassLoader parent, String name) {
        super(parent);
        this.name = name;
    }
    /**
     * 重写findClass方法
     */
    @Override
    public Class<?> findClass(String name) {
        byte[] data = loadClassData(name);
        return this.defineClass(name, data, 0, data.length);
    }
    public byte[] loadClassData(String name) {
        try {
            name = name.replace(".", "//");
            FileInputStream is = new FileInputStream(new File(path + name + ".class"));
            ByteArrayOutputStream baos = new ByteArrayOutputStream();
            int b = 0;
            while ((b = is.read()) != -1) {
                baos.write(b);
            }
            return baos.toByteArray();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return null;
    }
}

```

类加载器双亲委派模型是从JDK1.2以后引入的，并且只是一种推荐的模型，不是强制要求的，因此有一些没有遵循双亲委派模型的特例：(了解)
(1).在JDK1.2之前，自定义类加载器都要覆盖loadClass方法去实现加载类的功能，JDK1.2引入双亲委派模型之后，loadClass方法用于委派父类加载器进行类加载，只有父类加载器无法完成类加载请求时才调用自己的findClass方法进行类加载，因此在JDK1.2之前的类加载的loadClass方法没有遵循双亲委派模型，因此在JDK1.2之后，自定义类加载器不推荐覆盖loadClass方法，而只需要覆盖findClass方法即可。
(2).双亲委派模式很好地解决了各个类加载器的基础类统一问题，越基础的类由越上层的类加载器进行加载，但是这个基础类统一有一个不足，当基础类想要调用回下层的用户代码时无法委派子类加载器进行类加载。为了解决这个问题JDK引入了ThreadContext线程上下文，通过线程上下文的setContextClassLoader方法可以设置线程上下文类加载器。
JavaEE只是一个规范，sun公司只给出了接口规范，具体的实现由各个厂商进行实现，因此JNDI，JDBC,JAXB等这些第三方的实现库就可以被JDK的类库所调用。线程上下文类加载器也没有遵循双亲委派模型。
(3).近年来的热码替换，模块热部署等应用要求不用重启java虚拟机就可以实现代码模块的即插即用，催生了OSGi技术，在OSGi中类加载器体系被发展为网状结构。OSGi也没有完全遵循双亲委派模型。



##### 4.动态加载Jar && ClassLoader 隔离问题

动态加载Jar：
Java 中动态加载 Jar 比较简单，如下：
URL[] urls = new URL[] {new URL("file:libs/jar1.jar")};URLClassLoader loader = new URLClassLoader(urls, parentLoader);
表示加载 libs 下面的 jar1.jar，其中 parentLoader 就是上面1中的 parent，可以为当前的 ClassLoader。
ClassLoader 隔离问题：
大家觉得一个运行程序中有没有可能同时存在两个包名和类名完全一致的类？
JVM 及 Dalvik 对类唯一的识别是 ClassLoader id + PackageName + ClassName，所以一个运行程序中是有可能存在两个包名和类名完全一致的类的。并且如果这两个”类”不是由一个 ClassLoader 加载，是无法将一个类的示例强转为另外一个类的，这就是 ClassLoader 隔离。 如 Android 中碰到如下异常
android.support.v4.view.ViewPager can not be cast to android.support.v4.view.ViewPager

当碰到这种问题时可以通过 instance.getClass().getClassLoader(); 得到 ClassLoader，看 ClassLoader 是否一样。

加载不同 Jar 包中公共类：
现在 Host 工程包含了 common.jar, jar1.jar, jar2.jar，并且 jar1.jar 和 jar2.jar 都包含了 common.jar，我们通过 ClassLoader 将 jar1, jar2 动态加载进来，这样在 Host 中实际是存在三份 common.jar，如下图：
![img](D:\资料\面试\images\14301963930_2f0f0fe8aa_o.png)
我们怎么保证 common.jar 只有一份而不会造成上面3中提到的 ClassLoader 隔离的问题呢，其实很简单，在生成 jar1 和 jar2 时把 common.jar 去掉，只保留 host 中一份，以 host ClassLoader 为 parentClassLoader 即可。

#### 一道面试题

能不能自己写个类叫java.lang.System？
答案：通常不可以，但可以采取另类方法达到这个需求。 
解释：为了不让我们写System类，类加载采用委托机制，这样可以保证爸爸们优先，爸爸们能找到的类，儿子就没有机会加载。而System类是Bootstrap加载器加载的，就算自己重写，也总是使用Java系统提供的System，自己写的System类根本没有机会得到加载。
但是，我们可以自己定义一个类加载器来达到这个目的，为了避免双亲委托机制，这个类加载器也必须是特殊的。由于系统自带的三个类加载器都加载特定目录下的类，如果我们自己的类加载器放在一个特殊的目录，那么系统的加载器就无法加载，也就是最终还是由我们自己的加载器加载。



### 异常

![img](D:\资料\面试\images\349046_1471141680077_ADA0A68BAFF832DA663122A7AF549EE)



### Date、Calendar、Timestamp的区别

1 Java.util.Date
包含年、月、日、时、分、秒信息。

```java
// String转换为Date

String dateStr="2013-8-13 23:23:23";

String pattern="yyyy-MM-dd HH:mm:ss";

DateFormate dateFormat=new SimpleDateFormat(pattern);

Date date=dateFormat.parse(dateStr);

date=dateFormat.format(date);
```

2 Java.sql.Date
包含年、月、日信息。
继承自java.util.Date。在数据库相关操作中使用，如rs.getDate，ps.setDate等。rs是指ResultSet，ps是指PreparedStatement。

```java
// java.util.Date转换为java.sql.Date

new java.sql.Date(utilDate.getTime());// 其中utilDate为java.util.Date类型的对象
```

3 Java.util.Calendar
包含年、月、日、时、分、秒、毫秒信息。
JDK1.1引入，用以代替java.util.Date。

```java
// Date转为Calendar

Date date=new Date();

Calendar calendar=Calendar.getInstance();

calendar.setTime(date);

// Calendar转为Date

Calendar ca=Calendar.getInstance(); 

Date d =(Date) ca.getTime();
```

 

4 Java.sql.Timestamp
包含年、月、日、时、分、秒、纳秒（nano）信息。
继承自java.util.Date。比java.sql.Date包含更多信息。在数据库相关操作中使用，如rs.getTimestamp，ps.setTimeStamp等。例如：若数据库中某字段hireDate为Oracle的Date类型，则使用getTimestamp时能够将年、月、日、时、分、秒信息取出；但使用getDate时则只能取出年、月、日信息。因此，一般推荐使用getTimestamp。

```java
// java.util.Calendar转换为java.sql.Timestamp

new Timestamp(Calendar.getInstance().getTimeInMillis());

// java.util.Date转换为java.sql.Timestamp

new Timestamp(date.getTime());

// String转换为java.sql.Timestamp，String格式：yyyy-mm-dd hh:mm:ss[.f...] ，方括号表示可选

Timestamp.valueOf("2013-07-06 01:49:30");
```

5 Oracle数据库提供的日期和时间类型
Oracle数据库提供了DATE，TIMESTAMP，TIMESTAMP WITH TIME ZONE和TIMESTAMP WITH LOCAL TIME ZONE四种类型。
DATE包含世纪、年、月、日、时、分、秒信息。
TIMESTAMP是DATE的扩展，包含年、月、日、时、分、秒和fractional seconds信息。定义TIMESTAMP的格式如下：


TIMESTAMP [(fractional_seconds_precision)]

// 格式

TIMESTAMP 'YYYY-MM-DD HH24:MI:SS.FF'

// 一个例子

TIMESTAMP '1997-01-31 09:26:50.12'

其中fractional_seconds_precision是可选的，用于指定秒使用含几位小数的浮点数表示，它的取值范围是0到9，默认是6。上述例子中表示采用两位小数，它的秒值是50.12。注意：12不是毫秒值，也不是微秒值。 



### HashMap

作者：全网搜索关注JavaEdge
链接：https://www.nowcoder.com/discuss/151172
来源：牛客网



#### 1 概述

HashMap是基于哈希表实现的,每一个元素是一个key-value对,其内部通过单链表解决冲突问题,容量不足(超过了阀值)时,同样会自动增长.

HashMap是非线程安全的,只适用于单线程环境,多线程环境可以采用并发包下的concurrentHashMap

HashMap 实现了Serializable接口，因此它支持序列化，实现了Cloneable接口，能被克隆

HashMap是基于哈希表的Map接口的非同步实现.此实现提供所有可选的映射操作,并允许使用null值和null键.此类不保证映射的顺序,特别是它不保证该顺序恒久不变.

Java8中又对此类底层实现进行了优化，比如引入了红黑树的结构以解决哈希碰撞

#### 2 HashMap的数据结构

在Java中,最基本的结构就是两种,一个是数组,另外一个是模拟指针(引用),所有的数据结构都可以用这两个基本结构来构造,HashMap也不例外.
HashMap实际上是一个"链表散列"的数据结构,即数组和链表的结合体.

![HashMap的结构](D:\资料\面试\images\7380095_1547176001612_4685968-cd353393ebc2ddf7.png)

HashMap的主结构类似于一个数组,添加值时通过key确定储存位置.
每个位置是一个Entry的数据结构,该结构可组成链表.
当发生冲突时,相同hash值的键值对会组成链表.
这种数组+链表的组合形式大部分情况下都能有不错的性能效果,Java6、7就是这样设计的.
然而,在极端情况下,一组（比如经过精心设计的）键值对都发生了冲突，这时的哈希结构就会退化成一个链表，使HashMap性能急剧下降.

所以在Java8中,HashMap的结构实现变为数组+链表+红黑树

![Java8 HashMap的结构](D:\资料\面试\images\7380095_1547175998524_4685968-0e08421c5183e8ec.png)

可以看出,HashMap底层就是一个数组结构
数组中的每一项又是一个链表
当新建一个HashMap时,就会初始化一个数组.



```java
//Node本质上是一个Map.存储着key-value
    static class Node<K,V> implements Map.Entry<K,V> {
        final int hash;             //保存该桶的hash值
        final K key;                //不可变的key
        V value;                    
        Node<K,V> next;      //指向一个数据的指针

        Node(int hash, K key, V value, Node<K,V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }
```

从源码上可以看到，Node实现了Map.Entry接口，本质上是一个映射(k-v)
刚刚也说过了，有时候两个key的hashCode可能会定位到一个桶中，这时就发生了hash冲突，如果HashMap的hash算法越散列，那么发生hash冲突的概率越低，如果数组越大，那么发生hash冲突的概率也会越低，但是数组越大带来的空间开销越多，但是遍历速度越快，这就要在空间和时间上进行权衡，这就要看看HashMap的扩容机制，在说扩容机制之前先看几个比较重要的字段


```java
//默认桶16个
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16

//默认桶最多有2^30个
static final int MAXIMUM_CAPACITY = 1 << 30;

//默认负载因子是0.75
static final float DEFAULT_LOAD_FACTOR = 0.75f;

//能容纳最多key_value对的个数
 int threshold;

//一共key_value对个数
int size;
```

threshold=负载因子 * length，也就是说数组长度固定以后， 如果负载因子越大，所能容纳的元素个数越多，如果超过这个值就会进行扩容(默认是扩容为原来的2倍)，0.75这个值是权衡过空间和时间得出的，建议大家不要随意修改，如果在一些特殊情况下，比如空间比较多，但要求速度比较快，这时候就可以把扩容因子调小以较少hash冲突的概率。相反就增大扩容因子(这个值可以大于1)。
size就是HashMap中键值对的总个数。还有一个字段是modCount，记录是发生内部结构变化的次数，如果put值，但是put的值是覆盖原有的值，这样是不算内部结构变化的。
 因为HashMap扩容每次都是扩容为原来的2倍，所以length总是2的次方，这是非常规的设置，常规设置是把桶的大小设置为素数，因为素数发生hash冲突的概率要小于合数，比如HashTable的默认值设置为11，就是桶的大小为素数的应用(HashTable扩容后不能保证是素数)。HashMap采用这种设置是为了在取模和扩容的时候做出优化。
hashMap是通过key的hashCode的高16位和低16位异或后和桶的数量取模得到索引位置，即key.hashcode()^(hashcode>>>16)%length,当length是2^n时，h&（length-1）运算等价于h%length，而&操作比%效率更高。而采用高16位和低16位进行异或，也可以让所有的位数都参与越算，使得在length比较小的时候也可以做到尽量的散列。
在扩容的时候，如果length每次是2^n，那么重新计算出来的索引只有两种情况，一种是 old索引+16，另一种是索引不变，所以就不需要每次都重新计算索引。 

#### 3 确定哈希桶数据索引位置


```java
//方法一：
static final int hash(Object key) {   //jdk1.8 & jdk1.7
     int h;
     // h = key.hashCode() 为第一步 取hashCode值
     // h ^ (h >>> 16)  为第二步 高位参与运算
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
//方法二：
static int indexFor(int h, int length) {  //jdk1.7的源码，jdk1.8没有这个方法，但是实现原理一样的
     return h & (length-1);  //第三步 取模运算
}
```

#### 4 HashMap的put方法实现

 思路如下：
1.table[]是否为空
2.判断table[i]处是否插入过值
3.判断链表长度是否大于8，如果大于就转换为红黑二叉树，并插入树中
4.判断key是否和原有key相同，如果相同就覆盖原有key的value，并返回原有value
5.如果key不相同，就插入一个key，记录结构变化一次


```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
//判断table是否为空，如果是空的就创建一个table，并获取他的长度
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
//如果计算出来的索引位置之前没有放过数据，就直接放入
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
//进入这里说明索引位置已经放入过数据了
            Node<K,V> e; K k;
//判断put的数据和之前的数据是否重复
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))   //key的地址或key的equals()只要有一个相等就认为key重复了，就直接覆盖原来key的value
                e = p;
//判断是否是红黑树，如果是红黑树就直接插入树中
            else if (p instanceof TreeNode)
                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
            else {
//如果不是红黑树，就遍历每个节点，判断链表长度是否大于8，如果大于就转换为红黑树
                for (int binCount = 0; ; ++binCount) {
                    if ((e = p.next) == null) {
                        p.next = newNode(hash, key, value, null);
                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            treeifyBin(tab, hash);
                        break;
                    }
//判断索引每个元素的key是否可要插入的key相同，如果相同就直接覆盖
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        break;
                    p = e;
                }
            }
//如果e不是null，说明没有迭代到最后就跳出了循环，说明链表中有相同的key，因此只需要将value覆盖，并将oldValue返回即可
            if (e != null) { // existing mapping for key
                V oldValue = e.value;
                if (!onlyIfAbsent || oldValue == null)
                    e.value = value;
                afterNodeAccess(e);
                return oldValue;
            }
        }
//说明没有key相同，因此要插入一个key-value，并记录内部结构变化次数
        ++modCount;
        if (++size > threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }
```

#### 5 HashMap的get方法实现

 实现思路：
1.判断表或key是否是null，如果是直接返回null
2.判断索引处第一个key与传入key是否相等，如果相等直接返回
3.如果不相等，判断链表是否是红黑二叉树，如果是，直接从树中取值
4.如果不是树，就遍历链表查找

```java
final Node<K,V> getNode(int hash, Object key) {
        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;
//如果表不是空的，并且要查找索引处有值，就判断位于第一个的key是否是要查找的key
        if ((tab = table) != null && (n = tab.length) > 0 &&
            (first = tab[(n - 1) & hash]) != null) {
            if (first.hash == hash && // always check first node
                ((k = first.key) == key || (key != null && key.equals(k))))
//如果是，就直接返回
                return first;
//如果不是就判断链表是否是红黑二叉树，如果是，就从树中取值
            if ((e = first.next) != null) {
                if (first instanceof TreeNode)
                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);
//如果不是树，就遍历链表
                do {
                    if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                        return e;
                } while ((e = e.next) != null);
            }
        }
        return null;
    }
```

#### 6 扩容机制

我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。看下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。

![hashMap 1.8 哈希算法例图1](D:\资料\面试\images\SouthEast1)

元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化

![hashMap 1.8 哈希算法例图2](D:\资料\面试\images\SouthEast3)

因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：

![jdk1.8 hashMap扩容例图](D:\资料\面试\images\SouthEast4)

这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。这一块就是JDK1.8新增的优化点。有一点注意区别，JDK1.7中rehash的时候，旧链表迁移新链表的时候，如果在新表的数组索引位置相同，则链表元素会倒置，但是从上图可以看出，JDK1.8不会倒置。



### IO流

![这里写图片描述](D:\资料\面试\images\701)



### 多线程

- 程序：代码的集合；（静态的）
- 进程：正在运行的程序(动态的)
- 线程：程序中可运行的最小单元（小任务），一个程序中可包含多个线程；

#### 如何实现多线程的程序呢？

​	继承Thread类，Thread是线程类；然后重写run方法；run方法被称为线程体；

#### 线程中常用的方法

​	run():线程体，这个方法需要重写，线程执行的代码写在此方法中;
​	sleep():休眠
每个程序至少有一个线程，这个线程是主线程；如果在主线程中创建并启动多个子线程，那么这个程序就是多线程的，否则它只是单线程的；

#### 线程的生命周期

​	![img](D:\资料\面试\images\649752_1470463821884_0_1330790977pLQd.gif)

新生->就绪->运行->阻塞->死亡
线程中的方法；
	getId():获得当前线程的唯一标识；
	getName():获得线程的名子
	setPriority()/getPriority:设置/获取线程优先级
	join():加入线程
	setDaemon():设置当前线程为守护(精灵)线程
	sleep():休眠一定的时间；
	yield():让步
	currentThread:获得当前线程

#### 什么是守护线程

​	守护线程是优先级比较低的线程，如果程序中只有守护线程未结束，那么程序会退出执行；
​	可通过setDaemon(true)将当前线程标识成守护线程;

#### 线程的优先级；

​	java中线程的优先级分为10个等级，分别是1~10
​	setPriority(Thread.MAX_PRIORITY);

#### 实现线程的第二种方式是实现Runnable接口

##### Thread与Runnable的区别？

Thread与Runnable都可以实现多线程，但Runnable是接口，如果一个类已经继承了一个父类，则不能再继承Thread ,这时可以使用Runnable
Thread是一个线程，而Runnable只是线程中可执行的那个方法的封装；
创建线程的代码不同；
		A extends Thread,B implements Runnable
		A a=new A();
		Thread t=new Thread(new B());
定义三个车站，共卖100张票，输出每个车站卖的票号，卖完后，程序结束；

#### 多线程访问同一个公共资源时会产生资源竞争的问题；

临界区：访问共享资源的代码段，临界区中的代码只允许一个线程来访问；

##### synchronized块；

​	我们可以将访问同一个资源的代码放在一个同步块中；同步块需要有一个监视器(monitor),监听器可以是任何对象，但要保证，多个线程中使用的是同一个monitor;这样才能起到同步的作用；
​	语法是
​	synchronized(monitor){
​		代码段
​	}
​	注意：同步块中的代码尽量少（访问资源的相关代码放在此块中，其它无关代码无需放在此块中）；
同步方法
​	通过synchronized关键字进行修饰的方法就是同步方法；

##### volatile关键字

可以修饰属性；它在多线程环境上使用，是最轻量级的锁；它的作用是，当多个线程使用同一个使用了volatile修饰的属性时，当一个线程对这个属性进行修改后，其它线程可以立即获得这个值；
使用volatile的注意事项
volatile不支持原子操作；例如count++;
volatile非常适合设置线程的某个标识信息，例如退出标志，暂停标志等；
它是最轻量级的锁，比synchonized节省资源
原子类
	java5针对一些数据类型的常用操作封装了一些原子类；主要包括四种；
	基本数据类型
	数组
	引用类型
	Updater:

##### Lock锁

​	Lock锁是语义级别的锁；
​	使用Lock锁的步骤

1. 创建锁；
2. 加锁
3. 操作
4. 解锁

##### Lock与synchronized的区别？

从用法上
		synchronized可以修饰方法和块；使用简单，不需要通过编码进行加锁，同时可自动释放锁；
		Lock的用法是，先创建锁对象，然后再手动加锁和释放锁			

```java
	l.lock();
	try{
	
	}finally{
		l.unlock();
	}
```
功能上
		Lock锁分为排它锁和读写锁；Lock锁还增加了一些额外的功能；(trylock()等),另外Lock锁可以使用公平参数来保证获得锁的顺序；
		Lock非常适合高并发环境下使用；

#### notify与notifyAll的区别？

​	notify是唤醒使用同一个monitor的，等待池中的单一线程，notifyll唤醒的是所有线程，无论是哪个方法，都将被唤醒的线程置为锁池状态(等待获得锁)

#### sleep与wait()的区别？

sleep是Thread的方法，而wait是Object的方法；
sleep是休眠一段时间后，进入就绪态，wait是休眠后，直到同一个monitor的其它调用notify或notifyAll将其唤醒；
wait方法必须放在同步块或同步方法中使用，sleep则不需要；
wait会释放锁，sleep不会；

#### 死锁；

​	多（两）个线程中互相等待对方释放资源而引发的线程无法正常执行的问题；
​	解决办法：
​		1.使用资源时以固定的顺序来获得
​		2.出现死锁时，由第三方来释放某一个线程的资源
​		3.使用超时机制，当超过了某个时长，主动释放当前线程所锁定的资源；
案例；哲学家就餐



### 反射技术

编程语言的另一种分类方式
	动态语言：创建一个对象后，可以动态的为对象增加属性和方法；
	非动态语言：java
java不是动态语言，但我们可以通过反射机制实现动态语言的一些特征；

#### 什么是反射

​	程序在运行过程中，识别类(接口)的能力.
​	在运行过程中，可以读取元数据.

#### Class

​	Class:是反射机制的入口；代表类实例，通过Class类型的实例，我可以读出这个类的所有元数据；
​	Class没有public的构造方法，因此不能自己new;

##### 获得Class实例三种方法；

- ​	Class c =类名.class;
- ​	Class c1=Class.forName("类的完整名");
- ​	Class c2=对象.getClass();

##### Class的常用方法

- getName():返回一个类的类名(含包名)
- getSimpleName():类名(不含包名)
- getSuperClass():获得父类实例 
- getInterfaces():获得所有接口实例
- getModifiers():修饰符

#### Field类

​	Field代表一个属性；
​		Filed中包含属性名，数据类型，修饰符，

##### 获得Filed的四个方法(都是Class为我们提供的)

- ​	getDeclaredFields():当前类中定义的所有的属性；
- ​	getDeclaredField(String):根据属性名获取一个属性
- ​	getFields():获得所有公共的属性(包括父类)
- ​	getFiled(String):根据名称获得

##### Field的用法；

- ​	getName:获得属性名
- ​	getType:获得属性类型(Class)
- ​	getModifiers:获得修饰符；用一个整型数来表示；
- ​	get(Object):获得某个对象的属性值;
- ​	set(Object,Object):为某个对象的属性赋值
- ​	==setAccessible(true):设置可访问性;==

##### Field的实例

​	定义一个方法 public void save(Object obj);
​	向数据库中插入一个vo对象；
​		Book;
​		Student
​		Teacher 

	重点：
		1.通过反射获得所有的属性值并生成sql;
		2.通过jdbc执行sql
#### Method 

​	Method代表方法的所有元数据；元数据包括方法名，参数类型，返回值类型,修饰符等
​	Method的主要作用是用来调用;

##### 获取Method的方法

- ​	getMethods():获得所的公共方法();
- ​	getMethod(String,Class...args):根据名称和参数类型来获得一个方法；
- ​	getDeclaredMethods():所有定义的方法；
- ​	getDeclaredMethod():某一个定义的方法；

##### Method的常用方法

- ​	getName():方法名
- ​	getModifiers():修饰符
- ​	getReturnType():获得返回值类型
- ​	getParameterTypes():获得所有参数的类型
- ​	invoke(Object,Object...args)

#### Constructor

​	Constructor代表类中的一个构造方法；作用是用来实例化对象

##### 如何获得Constructor

- ​	getDeclaredConstructors():所有构造方法
- ​	getDeclaredConstructor(Class...args):获得一个构造方法

##### Constructor的方法

- ​	newInstance(Object...args):通过构造方法实例化对象；	
- ​	除了可以使用Constructor来实例化对象外，还可以使用Class.newInstance()方法来实例化某个类型的对象



### Annotation(注解)

​	JDK5;
Annotation
​	注解；
​	给编译器看的注释;
​	作用：给各个元数据打标记(对元数据的说明),并且在开发，分析，部署工具中获得这些数据；

#### java中预定的注解

- ​	@Override:方法重写，只能用在方法上;
- ​	@Deprecated:过期的
- ​	@SuppressWarning:压制警告

#### 自定义注解

​	一个注解应该包含什么？
​	@Target:目标,此注解给谁(元数据)用.
​	@Retention:注解的保留时间(Source,Class,Runtime)
​	属性值:
定义注解的语法

	@Target(ElementType.FIELD)
	@Retention(RetentionPolicy.RUNTIME)
	public @interface PK{
		boolean value() default true;
	}
	
	注意：如果注解中包含一个属性值，建议使用value(),因为在使用时，可以不用说明属性名；
@Property
	表 Book; book_name;
	vo Book; bookName

#### 通过反射获得Annotation

获得元数据(Class,Field,Method...)
再获得这个元数据(Class,Field,Method)之上的Annotation
可以通过以下方法来获得Annotation
		f.getAnnotations();//获得所有注解
		f.getAnnotation(Class)//某种类型的注解
		f.isAnnotationPresent(Class)//判断此Field中是否含有某种注解;














# 算法

## 求x的y次方，想出比直接for循环更好的方案

迭代

## 求绝对众数

(1)快速排序  
快速排序之后在数列中间的数是绝对众数  
(2)摩尔投票法  
摩尔投票法的基本思想很容易理解，在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。循环执行这一操作，直到无法再进行投票，如果数组为空，则没有任何元素出现的次数超过该数组长度的一半（无绝对众数）。如果只存在一种元素，那么这个元素则可能为绝对众数。 